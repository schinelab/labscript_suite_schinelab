# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from enum import IntEnum


import ctypes
import sys
import os
import re
import platform
import fnmatch



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _gentl
else:
    import _gentl

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _gentl.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gentl.delete_SwigPyIterator

    def value(self):
        return _gentl.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _gentl.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _gentl.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _gentl.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _gentl.SwigPyIterator_equal(self, x)

    def copy(self):
        return _gentl.SwigPyIterator_copy(self)

    def next(self):
        return _gentl.SwigPyIterator_next(self)

    def __next__(self):
        return _gentl.SwigPyIterator___next__(self)

    def previous(self):
        return _gentl.SwigPyIterator_previous(self)

    def advance(self, n):
        return _gentl.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _gentl.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _gentl.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _gentl.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _gentl.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _gentl.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _gentl.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _gentl:
_gentl.SwigPyIterator_swigregister(SwigPyIterator)


class GC_ERROR_LIST(IntEnum):
    """
    Defines status code of the last execution.
    """
    GC_ERR_SUCCESS             = 0  #: Operation was successful; no error occurred.
    GC_ERR_ERROR               = -1001  #: Unspecified runtime error.
    GC_ERR_NOT_INITIALIZED     = -1002  #: Module or resource not initialized.
    GC_ERR_NOT_IMPLEMENTED     = -1003  #: Requested operation not implemented.
    GC_ERR_RESOURCE_IN_USE     = -1004  #: Requested resource is already in use.
    GC_ERR_ACCESS_DENIED       = -1005  #: Requested operation is not allowed; e.g., a remote device is opened by another client.
    GC_ERR_INVALID_HANDLE      = -1006  #: Given handle does not support the operation; e.g., function call on wrong handle or NULL pointer.
    GC_ERR_INVALID_ID          = -1007  #: ID could not be connected to a resource; e.g., a device with the given ID is currently not available.
    GC_ERR_NO_DATA             = -1008  #: The function has no data to work on.
    GC_ERR_INVALID_PARAMETER   = -1009  #: One of the parameter given was not valid or out of range.
    GC_ERR_IO                  = -1010  #: Communication error has occurred; e.g., a read or write operation to a remote device failed.
    GC_ERR_TIMEOUT             = -1011  #: An operation's timeout time expired before it could be completed.
    GC_ERR_ABORT               = -1012  #: An operation has been aborted before it could be completed. For example a wait operation through :meth:`~gentl.IEventManager.update_event_data` method has been terminated via a call to :meth:`~gentl.IEventManager.flush_event_queue` method.
    GC_ERR_INVALID_BUFFER      = -1013  #: The GenTL Consumer has not announced enough buffers to start the acquisition in the currently active acquisition mode.
    GC_ERR_NOT_AVAILABLE       = -1014  #: Resource or information is not available at a given time in a current state.
    GC_ERR_INVALID_ADDRESS     = -1015  #: A given address is out of range or invalid for internal reasons.
    GC_ERR_BUFFER_TOO_SMALL    = -1016  #: A provided buffer is too small to receive the expected amount of data. This may affect acquisition buffers in the Data Stream module if the buffers are smaller than the expected payload size but also buffers passed to any other function of the GenTL Producer interface to retrieve information or IDs.
    GC_ERR_INVALID_INDEX       = -1017  #: A provided index referencing a Producer internal object is out of bounds.
    GC_ERR_PARSING_CHUNK_DATA  = -1018  #: An error occurred parsing a buffer containing chunk data.
    GC_ERR_INVALID_VALUE       = -1019  #: A register write function was trying to write an invalid value.
    GC_ERR_RESOURCE_EXHAUSTED  = -1020  #: A requested resource is exhausted. This is a rather general error which might for example refer to a limited number of available handles being available.
    GC_ERR_OUT_OF_MEMORY       = -1021  #: The system and/or other hardware in the system (frame grabber) ran out of memory.
    GC_ERR_BUSY                = -1022  #: The required operation cannot be executed because the responsible module/entity is busy executing actions that cannot be performed concurrently with the requested operation.

    GC_ERR_CUSTOM_ID           = -10000  #: Any error smaller or equal than -10000 is implementation specific.


class INFO_DATATYPE_LIST(IntEnum):
    """
    Defines the data types possible for the various Info functions. The data type itself may define its size.
    """
    INFO_DATATYPE_UNKNOWN     = 0  #: Unknown data type. This value is never returned from a function but can be used to initialize the variable to inquire the type.
    INFO_DATATYPE_STRING      = 1  #: 0-terminated C string (encoding according to the :const:`~gentl.TL_INFO_CMD_LIST.TL_INFO_CHAR_ENCODING` info command).
    INFO_DATATYPE_STRINGLIST  = 2  #: Concatenated :const:`~gentl.INFO_DATATYPE_LIST.INFO_DATATYPE_STRING` list. End of list is signaled with an additional 0.
    INFO_DATATYPE_INT16       = 3  #: Signed 16 bit integer.
    INFO_DATATYPE_UINT16      = 4  #: Unsigned 16 bit integer.
    INFO_DATATYPE_INT32       = 5  #: Signed 32 bit integer.
    INFO_DATATYPE_UINT32      = 6  #: Unsigned 32 bit integer.
    INFO_DATATYPE_INT64       = 7  #: Signed 64 bit integer.
    INFO_DATATYPE_UINT64      = 8  #: Unsigned 64 bit integer.
    INFO_DATATYPE_FLOAT64     = 9  #: Signed 64 bit floating point number.
    INFO_DATATYPE_PTR         = 10  #: Pointer type (void*). Size is platform dependent (32 bit on 32 bit platforms)
    INFO_DATATYPE_BOOL8       = 11  #: Boolean value occupying 8 bit. 0 for false and anything for true.
    INFO_DATATYPE_SIZET       = 12  #: Platform dependent unsigned integer (32 bit on 32 bit platforms)
    INFO_DATATYPE_BUFFER      = 13  #: Like a :const:`~gentl.INFO_DATATYPE_LIST.INFO_DATATYPE_STRING` but with arbitrary data and no 0 termination.
    INFO_DATATYPE_PTRDIFF     = 14  #: The type ptrdiff_t is a type that can hold the result of subtracting two pointers.

    INFO_DATATYPE_CUSTOM_ID   = 1000  #: Starting value for Custom IDs which are implementation specific.


class TL_CHAR_ENCODING_LIST(IntEnum):
    """
    Char encoding schemata.
    """
    TL_CHAR_ENCODING_ASCII    = 0  #: Char encoding of the GenTL Producer is ASCII.
    TL_CHAR_ENCODING_UTF8     = 1  #: Char encoding of the GenTL Producer is UTF8.


class TL_INFO_CMD_LIST(IntEnum):
    """
    Defines system module information commands. The reported information through these two functions must be in sync.
    """
    TL_INFO_ID              = 0  #: Unique ID identifying a GenTL Producer. For example the filename of the GenTL Producer implementation including its path.
    TL_INFO_VENDOR          = 1  #: GenTL Producer vendor name.
    TL_INFO_MODEL           = 2  #: GenTL Producer model name. For example: A vendor produces more than one GenTL Producer for different device classes or different technologies. The :const:`~gentl.TL_INFO_CMD_LIST.TL_INFO_MODEL` references a single GenTL Producer implementation. The combination of Vendor and Model provides a unique reference of ONE GenTL Producer implementation.
    TL_INFO_VERSION         = 3  #: GenTL Producer version.
    TL_INFO_TLTYPE          = 4  #: Transport layer technology that is supported.
    TL_INFO_NAME            = 5  #: File name including extension of the library.
    TL_INFO_PATHNAME        = 6  #: Full path including file name and extension of the library.
    TL_INFO_DISPLAYNAME     = 7  #: User readable name of the GenTL Producer.
    TL_INFO_CHAR_ENCODING   = 8  #: The char encoding of the GenTL Producer.
    TL_INFO_GENTL_VER_MAJOR = 9  #: Major version number of GenTL Standard Version this Producer complies with.
    TL_INFO_GENTL_VER_MINOR = 10  #: Minor version number of GenTL Standard Version this Producer complies with.

    TL_INFO_CUSTOM_ID       = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class INTERFACE_INFO_CMD_LIST(IntEnum):
    """
    Defines named constants to retrieve the Interface module related information.
    """
    INTERFACE_INFO_ID              = 0  #: Unique ID of the interface.
    INTERFACE_INFO_DISPLAYNAME     = 1  #: User readable name of the interface.
    INTERFACE_INFO_TLTYPE          = 2  #: Transport layer technology that is supported.

    INTERFACE_INFO_CUSTOM_ID       = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class DEVICE_ACCESS_FLAGS_LIST(IntEnum):
    """
    Defines named constants how a device is to be opened.
    """
    DEVICE_ACCESS_UNKNOWN   = 0  #: Not used in a command. Can be used to initialize a variable to query that information.
    DEVICE_ACCESS_NONE      = 1  #: This either means that the device is not open because it was not opened before or the access to it was denied.
    DEVICE_ACCESS_READONLY  = 2  #: Opens the device read only. All Port functions can only read from the device.
    DEVICE_ACCESS_CONTROL   = 3  #: Opens the device in a way that other hosts/processes can have read only access to the device. Device access level is read/write for this process.
    DEVICE_ACCESS_EXCLUSIVE = 4  #: Open the device in a way that only this host/process can have access to the device. Device access level is read/write for this process.

    DEVICE_ACCESS_CUSTOM_ID = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class DEVICE_ACCESS_STATUS_LIST(IntEnum):
    """
    Defines named constants used to retrieve the current accessibility of the device.
    """
    DEVICE_ACCESS_STATUS_UNKNOWN      = 0  #: The current availability of the device is unknown.
    DEVICE_ACCESS_STATUS_READWRITE    = 1  #: The device is available to be opened for Read/Write access but it is currently not opened.
    DEVICE_ACCESS_STATUS_READONLY     = 2  #: The device is available to be opened for Read access but is currently not opened.
    DEVICE_ACCESS_STATUS_NOACCESS     = 3  #: The device is seen be the producer but is not available for access because it is not reachable.
    DEVICE_ACCESS_STATUS_BUSY         = 4  #: The device is already owned/opened by another entity.
    DEVICE_ACCESS_STATUS_OPEN_READWRITE = 5  #: The device is already owned/opened by this GenTL Producer with RW access.
    DEVICE_ACCESS_STATUS_OPEN_READONLY  = 6  #: The device is already owned/opened by this GenTL Producer with RO access.

    DEVICE_ACCESS_STATUS_CUSTOM_ID = 1000  #: Starting value for custom IDs which are implementation specific.


class DEVICE_INFO_CMD_LIST(IntEnum):
    """
    Defines named constants to retrieve the Device module related information.
    """
    DEVICE_INFO_ID                  = 0  #: Unique ID of the device.
    DEVICE_INFO_VENDOR              = 1  #: Device vendor name.
    DEVICE_INFO_MODEL               = 2  #: Device model name.
    DEVICE_INFO_TLTYPE              = 3  #: Transport layer technology that is supported.
    DEVICE_INFO_DISPLAYNAME         = 4  #: User readable name of the device. If this is not defined by the device this should be “VENDOR MODEL (ID)”.
    DEVICE_INFO_ACCESS_STATUS       = 5  #: Gets the access status the GenTL Producer has on the device.
    DEVICE_INFO_USER_DEFINED_NAME   = 6  #: String containing the user defined name of the device.
    DEVICE_INFO_SERIAL_NUMBER       = 7  #: Serial number of the device in string format.
    DEVICE_INFO_VERSION             = 8  #: Device version in string format.
    DEVICE_INFO_TIMESTAMP_FREQUENCY = 9  #: Tick frequency of the device's timestamp counter in ticks per second.

    DEVICE_INFO_CUSTOM_ID       = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class ACQ_STOP_FLAGS_LIST(IntEnum):
    """
    Defines named constants for the acquisition engine.
    """
    ACQ_STOP_FLAGS_DEFAULT    = 0  #: Stops the acquisition engine when the currently running tasks like filling a buffer are completed (default behavior).
    ACQ_STOP_FLAGS_KILL       = 1  #: Stop the acquisition engine immediately. In case this results in a partially filled buffer the Producer will return the buffer through the regular mechanism to the user, indicating through the info function of that buffer that this buffer is not complete.

    ACQ_STOP_FLAGS_CUSTOM_ID  = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class ACQ_START_FLAGS_LIST(IntEnum):
    """
    Defines named constants for the acquisition engine.
    """
    ACQ_START_FLAGS_DEFAULT     = 0  #: Default behavior.

    ACQ_START_FLAGS_CUSTOM_ID   = 1000  #: Starting value for GenTL Producer custom IDs.


class ACQ_QUEUE_TYPE_LIST(IntEnum):
    """
    Defines named constants from which to which queue/pool buffers are flushed.
    """
    ACQ_QUEUE_INPUT_TO_OUTPUT           = 0  #: Flushes the buffers from the input pool to the output buffer queue and if necessary adds entries in the :const:`~gentl.EVENT_TYPE_LIST.EVENT_NEW_BUFFER` event data queue. The buffers currently being filled are not affected by this operation. This only applies to the mandatory default buffer handling mode. The fill state of a buffer can be inquired through the buffer info command :const:`~gentl.BUFFER_INFO_CMD_LIST.BUFFER_INFO_NEW_DATA`. This allows the GenTL Consumer to maintain all buffers without a second reference in the GenTL Consumer because all buffers are delivered through the new buffer event.
    ACQ_QUEUE_OUTPUT_DISCARD            = 1  #: Discards all buffers in the output buffer queue and if necessary remove the entries from the event data queue.
    ACQ_QUEUE_ALL_TO_INPUT              = 2  #: Puts all buffers in the input pool. This is including those in the output buffer queue and the ones which are currently being filled and discard entries in the event data queue.
    ACQ_QUEUE_UNQUEUED_TO_INPUT         = 3  #: Puts all buffers that are neither in the input pool nor being currently filled nor in the output buffer queue in the input pool.
    ACQ_QUEUE_ALL_DISCARD               = 4  #: Discards all buffers in the input pool and the buffers in the output queue including buffers currently being filled so that no buffer is bound to any internal mechanism and all buffers may be revoked or requeued.

    ACQ_QUEUE_CUSTOM_ID                 = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class STREAM_INFO_CMD_LIST(IntEnum):
    """
    Defines named constants to retrieve the Data Stream related information.
    """
    STREAM_INFO_ID                         =  0  #: Unique ID of the data stream.
    STREAM_INFO_NUM_DELIVERED              =  1  #: Number of delivered buffers since last acquisition start.
    STREAM_INFO_NUM_UNDERRUN               =  2  #: Number of lost frames due to queue underrun. This number is initialized with zero at the time the stream is opened and incremented every time the data could not be acquired because there was no buffer in the input pool.
    STREAM_INFO_NUM_ANNOUNCED              =  3  #: Number of announced buffers.
    STREAM_INFO_NUM_QUEUED                 =  4  #: Number of buffers in the input pool plus the buffer(s) currently being  illed. This does not include the buffers in the output queue. The intention of this informational value is to prevent/early detect an underrun of the acquisition buffers.
    STREAM_INFO_NUM_AWAIT_DELIVERY         =  5  #: Number of buffers in the output buffer queue.
    STREAM_INFO_NUM_STARTED                =  6  #: Number of frames started in the acquisition engine. This number is incremented every time a new buffer is started to be filled (data written to) regardless if the buffer is later delivered to the user or discarded for any reason. This number is initialized with 0 at at the time of the stream is opened. It is not reset until the stream is closed.
    STREAM_INFO_PAYLOAD_SIZE               =  7  #: Size of the expected data in bytes.
    STREAM_INFO_IS_GRABBING                =  8  #: Flag indicating whether the acquisition engine is started or not. This is independent from the acquisition status of the remote device.
    STREAM_INFO_DEFINES_PAYLOADSIZE        =  9  #: Flag indicating that this data stream defines a payload size independent from the remote device. If false the size of the expected payload size is to be retrieved from the remote device. If true the expected payload size is to be inquired from the Data Stream module. In case the GenTL Producer does not support this command it is to interpreted as false.
    STREAM_INFO_TLTYPE                     = 10  #: Transport layer technology that is supported.
    STREAM_INFO_NUM_CHUNKS_MAX             = 11  #: Maximum number of chunks to be expected in a buffer (can be used to allocate the array for the :meth:`~gentl.DataStream.get_buffer_chunk_data` method). In case this is not known a priori by the GenTL Producer those methods return :const:`~gentl.GC_ERROR_LIST.GC_ERR_NOT_AVAILABLE`. This maximum must not change during runtime.
    STREAM_INFO_BUF_ANNOUNCE_MIN           = 12  #: Minimum number of buffers to announce.
    STREAM_INFO_BUF_ALIGNMENT              = 13  #: Alignment size in bytes of the buffer passed to :meth:`~gentl.DataStream.announce_buffer` method. If a buffer is passed to the method which is not aligned according to the alignment size it is up to the Producer to either reject the buffer and return the :const:`~gentl.GC_ERROR_LIST.GC_ERR_INVALID_BUFFER` error code or to cope with a potential overhead and use the unaligned buffer as is. In case there is no special alignment needed the GenTL Producer should report a 1.

    STREAM_INFO_CUSTOM_ID                  = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class BUFFER_INFO_CMD_LIST(IntEnum):
    """
    Defines named constants to retlieve the Buffer module related information.
    """
    BUFFER_INFO_BASE                            = 0  #: Base address of the buffer memory as passed to the :meth:`~gentl.DataStream.announce_buffer` function. This is also the address where the payload within the buffer starts.
    BUFFER_INFO_SIZE                            = 1  #: Size of the buffer in bytes.
    BUFFER_INFO_USER_PTR                        = 2  #: Private data pointer casted to an integer provided at buffer announcement using :meth:`~gentl.DataStream.announce_buffer` or :meth:`~gentl.DataStream.alloc_and_announce_buffer` by the GenTL Consumer. The pointer is attached to the buffer to allow attachment of user data to a buffer.
    BUFFER_INFO_TIMESTAMP                       = 3  #: Time stamp the buffer was acquired. The unit is device/implementation dependent. In case the technology and/or the device does not support this for example under Windows a :func:`QueryPerformanceCounter` can be used.
    BUFFER_INFO_NEW_DATA                        = 4  #: Flag to indicate that the buffer contains new data since the last delivery.
    BUFFER_INFO_IS_QUEUED                       = 5  #: If this flag is set to true the buffer is in the input pool, the buffer is currently being filled or the buffer is in the output buffer queue. In case this value is true the buffer is owned by the GenTL Producer and it can not be revoked.
    BUFFER_INFO_IS_ACQUIRING                    = 6  #: Flag to indicate that the buffer is currently being filled with data.
    BUFFER_INFO_IS_INCOMPLETE                   = 7  #: Flag to indicate that a buffer was filled but an error occurred during that process.
    BUFFER_INFO_TLTYPE                          = 8  #: Transport layer technology that is supported.
    BUFFER_INFO_SIZE_FILLED                     = 9  #: Number of bytes written into the buffer the last time it has been filled. This value is reset to 0 when the buffer is placed into the Input Buffer Pool. If the buffer is incomplete (such as if there are missing packets), only the number of bytes successfully written to the buffer are reported. If the buffer is complete, the number equals to the size reported through :const:`~gentl.BUFFER_INFO_CMD_LIST.BUFFER_INFO_DATA_SIZE`.
    BUFFER_INFO_WIDTH                           = 10  #: Width of the data in the buffer in number of pixels. This information refers for example to the width entry in the GigE Vision image stream data leader. For other technologies this is to be implemented accordingly.
    BUFFER_INFO_HEIGHT                          = 11  #: Height of the data in the buffer in number of pixels as configured. For variable size images this is the maximum height of the buffer. For example this information refers to the height entry in the GigE Vision image stream data leader. For other technologies this is to be implemented accordingly.
    BUFFER_INFO_XOFFSET                         = 12  #: XOffset of the data in the buffer in number of pixels from the image origin to handle areas of interest. This information refers for example to the information provided in the GigE Vision image stream data leader. For  other technologies this is to beimplemented accordingly.
    BUFFER_INFO_YOFFSET                         = 13  #: YOffset of the data in the buffer in number of lines from the image origin to handle areas of interest. This information refers for example to the information provided in the GigE Vision image stream data leader. For other technologies this is to be implemented accordingly.
    BUFFER_INFO_XPADDING                        = 14  #: XPadding of the data in the buffer in number of bytes. This information refers for example to the information provided in the GigE Vision image stream data leader. For other technologies this is may be implemented accordingly.
    BUFFER_INFO_YPADDING                        = 15  #: YPadding of the data in the buffer in number of bytes. This information refers for example to the information provided in the GigE Vision image stream data leader. For other thechnologies this may be implemented accordingly.
    BUFFER_INFO_FRAMEID                         = 16  #: A sequentially incremented number of the frame. This information refers for example to the information provided in the GigE Vision image stream block id. For other technologies this is to be implemented accordingly. The wrap around of this number is transportation technology dependent. For GigE Vision it is (so far) 16bit wrapping to 1. Other technologies may implement a larger bit depth.
    BUFFER_INFO_IMAGEPRESENT                    = 17  #: Flag to indicate if the current data in the buffer contains image data. This information refers for example to the information provided in the GigE Vision image stream data leader. For other technologies this is to be implemented accordingly.
    BUFFER_INFO_IMAGEOFFSET                     = 18  #: Offset of the image data from the beginning of the delivered buffer in bytes. Applies for example when delivering the image as part of chunk data or on technologies requiring specific buffer alignment.
    BUFFER_INFO_PAYLOADTYPE                     = 19  #: Payload type of the data. This information refers to the constants defined by :class:`~gentl.PAYLOADTYPE_INFO_IDS`.
    BUFFER_INFO_PIXELFORMAT                     = 20  #: Pixelformat of the data. This information refers for example to the information provided in the GigE Vision image stream data leader. For other technologies this is to be implemented accordingly. The interpretation of the pixel format depends on the namespace the pixel format belongs to. This can be  inquired using the :const:`~gentl.BUFFER_INFO_CMD_LIST.BUFFER_INFO_PIXELFORMAT_NAMESPACE` command.
    BUFFER_INFO_PIXELFORMAT_NAMESPACE           = 21  #: This information refers to the constants defined by :class:`~gentl.PIXELFORMAT_NAMESPACE_IDS` to allow interpretation of :const:`~gentl.BUFFER_INFO_CMD_LIST.BUFFER_INFO_PIXELFORMAT`.
    BUFFER_INFO_DELIVERED_IMAGEHEIGHT           = 22  #: The number of lines in the current buffer as delivered by the transport mechanism. For area scan type images this is usually the number of lines configured in the device. For variable size linescan images this number may be lower than the configured image height. This information refers for example to the information provided in the GigE Vision image stream data trailer. For other technologies this is to be implemented accordingly.
    BUFFER_INFO_DELIVERED_CHUNKPAYLOADSIZE      = 23  #: This information refers for example to the information provided in the GigE Vision image stream data trailer. For other technologies this is to be implemented accordingly.
    BUFFER_INFO_CHUNKLAYOUTID                   = 24  #: This information refers for example to the information provided in the GigE Vision image stream data leader. The chunk layout id serves as an indicator that the chunk layout has changed and the application should reparse the chunk layout in the buffer. When a chunk layout (availability or position of individual chunks) changes since the last buffer delivered by the device through the same stream, the device must change the chunk layout id. As long as the chunk layout remains stable, the camera must keep the chunk layout id intact. When switching back to a layout, which was already used before, the camera can use the same id again or use a new id. A chunk layout id value of 0 is invalid. It is reserved for use by cameras not supporting the layout id functionality. The algorithm used to compute the chunk layout id is left as quality of implementation. For other technologies this is to be implemented accordingly.
    BUFFER_INFO_FILENAME                        = 25  #: Filename in case the payload contains a file. This information refers for example to the information provided in the GigE Vision image stream data leader. For other technologies this is to be implemented accordingly. Since this is GigE Vision related information and the filename in GigE Vision is UTF8 coded, this filename is also UTF8 coded.
    BUFFER_INFO_PIXEL_ENDIANNESS                = 26  #: Endianness of the multi-byte pixel data in the buffer. This information refers to the constants defined by :class:`~gentl.PIXELENDIANNESS_IDS`.
    BUFFER_INFO_DATA_SIZE                       = 27  #: Size of the data intended to be written to the buffer last time it has been filled. This value is reset to 0 when the buffer is placed into the Input Buffer Pool. If the buffer is incomplete the number still reports the full size of the original data including the lost parts. If the buffer is complete, the number equals to the size reported through :const:`~gentl.BUFFER_INFO_CMD_LIST.BUFFER_INFO_SIZE_FILLED`.
    BUFFER_INFO_TIMESTAMP_NS                    = 28  #: Time stamp the buffer was acquired, in units of 1 ns (1 000 000 000 ticks per second). If the device is internally using another tick frequency than 1GHz, the GenTL Producer must convert the value to nanoseconds.
    BUFFER_INFO_DATA_LARGER_THAN_BUFFER         = 29  #: If this values is set to true it indicates that the payload transferred would not fit into the announced buffer and that therefore only parts of the payload or no payload (depending on the implementation of the GenTL Producer) is copied into the buffer.
    BUFFER_INFO_CONTAINS_CHUNKDATA              = 30  #: If this values is set to true it indicates that the payload transferred contains chunk data which may be parsed through a call to  the :meth:`~gentl.DataStream.get_buffer_chunk_data` method.

    BUFFER_INFO_CUSTOM_ID                       = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class BUFFER_PART_INFO_CMD_LIST(IntEnum):
    """
    Defines named constants to retrieve the Buffer module related information.

    In case an item of the enumeration is not available or not implemented these functions must return the appropriate error return value.
    """
    BUFFER_PART_INFO_BASE                       = 0  #: Base address of the buffer part memory. This is the address where the valid buffer part data start, not considering any padding between data parts or buffer alignment.
    BUFFER_PART_INFO_DATA_SIZE                  = 1  #: Size of the buffer part in bytes. Actual size of the data within this buffer part should be reported. Eventual padding between buffer parts is not included. In case of variable payload type only the size of valid data within the buffer part is reported.
    BUFFER_PART_INFO_DATA_TYPE                  = 2  #: Type of the data in given part. This information refers to the constants defined by :class:`~gentl.PARTDATATYPE_IDS`.
    BUFFER_PART_INFO_DATA_FORMAT                = 3  #: Format of the individual items (such as pixels) in the buffer part. The interpretation of the format is specific to every data type (:const:`~gentl.BUFFER_PART_INFO_CMD_LIST.BUFFER_PART_INFO_DATA_TYPE`), as specified in definitions of individual :class:`~gentl.PARTDATATYPE_IDS`. The actual meaning of the data format depends on the namespace the format belongs to which can be inquired using the :const:`~gentl.BUFFER_PART_INFO_CMD_LIST.BUFFER_PART_INFO_DATA_FORMAT_NAMESPACE` command (although for the standard :class:`~gentl.PARTDATATYPE_IDS` a recommended data format namespace is always specified).
    BUFFER_PART_INFO_DATA_FORMAT_NAMESPACE      = 4  #: This information refers to the constants defined by :class:`~gentl.PIXELFORMAT_NAMESPACE_IDS` to allow interpretation of :const:`~gentl.BUFFER_PART_INFO_CMD_LIST.BUFFER_PART_INFO_DATA_FORMAT`.
    BUFFER_PART_INFO_WIDTH                      = 5  #: Width of the data in the buffer part in number of pixels. If the information is not applicable to given data type, the query should result in :const:`~gentl.GC_ERROR_LIST.GC_ERR_NOT_AVAILABLE`.
    BUFFER_PART_INFO_HEIGHT                     = 6  #: Height of the data in the buffer part in number of pixels. If the information is not applicable to given data type, the query should result in :const:`~gentl.GC_ERROR_LIST.GC_ERR_NOT_AVAILABLE`.
    BUFFER_PART_INFO_XOFFSET                    = 7  #: XOffset of the data in the buffer part in number of pixels from the image origin to handle areas of interest. If the information is not applicable to given data type, the query should result in :const:`~gentl.GC_ERROR_LIST.GC_ERR_NOT_AVAILABLE`.
    BUFFER_PART_INFO_YOFFSET                    = 8  #: YOffset of the data in the buffer part in number of pixels from the image origin to handle areas of interest. If the information is not applicable to given data type, the query should result in :const:`~gentl.GC_ERROR_LIST.GC_ERR_NOT_AVAILABLE`.
    BUFFER_PART_INFO_XPADDING                   = 9  #: XPadding of the data in the buffer part in number of pixels. If the information is not applicable to given data type, the query should result in :const:`~gentl.GC_ERROR_LIST.GC_ERR_NOT_AVAILABLE`.
    BUFFER_PART_INFO_SOURCE_ID                  = 10  #: Identifier allowing to group data parts belonging to the same source (usually corresponding with the SourceSelector/ChunkSourceID features from SFNC). Parts marked with the same source_id can be pixelmapped together. Parts carrying data from different ROI's of the same source would typically be marked with the same source_id. It is not mandatory that source_id's within a given buffer make a contiguous sequence of numbers starting with zero. Note: for example with a dual-source 3D camera, the buffer can contain data parts carrying the 3D data and Confidence data corresponding to both of the two different sources. In this case the source ID helps to match the 3D and Confidence parts belonging together. This information refers for example to the information provided in the GigE Vision image stream multi-part data leader.
    BUFFER_PART_INFO_DELIVERED_IMAGEHEIGHT      = 11  #: The number of lines in the current buffer part as delivered by the transport mechanism. For area scan type images this is usually the number of lines configured in the device. For variable size linescan images this number may be lower than the configured image height. This information refers for example to the information provided in the GigE Vision image stream data trailer. For other technologies this is to be implemented accordingly.

    BUFFER_PART_INFO_CUSTOM_ID                  = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class PAYLOADTYPE_INFO_IDS(IntEnum):
    """
    Defines named constants to give a hint on the payload type to be expected in a Buffer module.
    """
    PAYLOAD_TYPE_UNKNOWN         =  0  #: The GenTL Producer is not aware of the payload type of the data in the provided buffer. For the GenTL Consumer perspective this can be handled as raw data.
    PAYLOAD_TYPE_IMAGE           =  1  #: The buffer payload contains image data. The GenTL Consumer can check if additional chunk data is available via the :class:`~gentl.BUFFER_INFO_LIST` commands.
    PAYLOAD_TYPE_RAW_DATA        =  2  #: The buffer payload contains raw and further unspecified data. This can be used to send acquisition statistics.
    PAYLOAD_TYPE_FILE            =  3  #: The buffer payload contains data of a file. It is used to transfer files such as JPEG compressed images which can be stored by the GenTLProducer directly to a hard disk. The user might get a hint how to interpret the buffer by the filename provided through a call to :meth:`~gentl.Buffer.get_buffer_part_info` mthods of :class:`~gentl.DataStream` class with the command :const:`~gentl.BUFFER_INFO_CMD_LIST.BUFFER_INFO_FILENAME`.
    PAYLOAD_TYPE_CHUNK_DATA      =  4  #: The buffer payload contains chunk data which can be parsed. The chunk data type might be reported through SFNC or deduced from the technology the device is based on. This constant is for backward compatibility with GEV 1.2 and is deprecated since GenTL version 1.5. From now on ChunkData can be part or any other payload type. Use the :const:`~gentl.BUFFER_INFO_CMD_LIST.BUFFER_INFO_CONTAINS_CHUNKDATA` commads to query if a given buffer content contains chunk data.
    PAYLOAD_TYPE_JPEG            =  5  #: The buffer payload contains JPEG data in the format described in GEV 2.0. The GenTL Producer should report additional information through the corresponding command of :class:`~gentl.BUFFER_INFO_CMD_LIST`.
    PAYLOAD_TYPE_JPEG2000        =  6  #: The buffer payload contains JPEG 2000 data in the format described in GEV 2.0. The GenTL Producer should report additional information through the corresponding command of :class:`~gentl.BUFFER_INFO_CMD_LIST`.
    PAYLOAD_TYPE_H264            =  7  #: The buffer payload contains H.264 data in the format described in GEV 2.0. The GenTL Producer should report additional information through the corresponding command of :class:`~gentl.BUFFER_INFO_CMD_LIST`.
    PAYLOAD_TYPE_CHUNK_ONLY      =  8  #: The buffer payload contains only chunk data but no additional payload.
    PAYLOAD_TYPE_DEVICE_SPECIFIC =  9  #: The buffer payload contains device specific data. The GenTL Producer should report additional information through the corresponding command of :class:`~gentl.BUFFER_INFO_CMD_LIST`.
    PAYLOAD_TYPE_MULTI_PART      =  10  #: The buffer payload contains multiple parts of different payload types. Information about the individual parts should be queried using :attr:`~gentl.DataStream.num_buffer_parts` and `get_buffer_part_info` methods of :class:`~gentl.DataStream` class.

    PAYLOAD_TYPE_CUSTOM_ID       = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class PIXELFORMAT_NAMESPACE_IDS(IntEnum):
    """
    Defines named constants to interpret the pixel formats provided through a Buffer module.
    """
    PIXELFORMAT_NAMESPACE_UNKNOWN      = 0  #: The interpretation of the pixel format values is unknown to the GenTL Producer.
    PIXELFORMAT_NAMESPACE_GEV          = 1  #: The interpretation of the pixel format values is referencing GigE Vision 1.x.
    PIXELFORMAT_NAMESPACE_IIDC         = 2  #: The interpretation of the pixel format values is referencing IIDC 1.x.
    PIXELFORMAT_NAMESPACE_PFNC_16BIT   = 3  #: The interpretation of the pixel format values is referencing PFNC 16Bit Values It is recommended to use the PFNC32 namespace when ever possible or even do the translation in the GenTL Producer since the support in GenTL consumers for it is expected to be much broader.
    PIXELFORMAT_NAMESPACE_PFNC_32BIT   = 4  #: The interpretation of the pixel format values is referencing PFNC 32Bit Values.

    PIXELFORMAT_NAMESPACE_CUSTOM_ID    = 1000  #: The interpretation of the pixel format values is GenTL Producer specific.


class PIXELENDIANNESS_IDS(IntEnum):
    """
    Defines named constants describing endianness of multi-byte pixel data in a buffer.
    """
    PIXELENDIANNESS_UNKNOWN  = 0  #: Endianness of the pixel data is unknown to the GenTL Producer.
    PIXELENDIANNESS_LITTLE   = 1  #: The pixel data is stored in little endian format.
    PIXELENDIANNESS_BIG      = 2  #: The pixel data is stored in big endian format.


class PARTDATATYPE_IDS(IntEnum):
    """
    Defines named constants to give a hint on the data type to be expected in the buffer part.
    """
    PART_DATATYPE_UNKNOWN              =  0  #: The GenTL Producer is not aware of the data type of the data in the provided buffer part. From the GenTL Consumer perspective this can be handled as raw data.
    PART_DATATYPE_2D_IMAGE             =  1  #: Color or monochrome (2D) image. This part carries all the pixel data of given image (even if the image is represented by a single-plane pixel format). It is recommended to use :const:`~gentl.PIXELFORMAT_NAMESPACE_IDS.PIXELFORMAT_NAMESPACE_PFNC_32BIT` data format with this data type whenever possible.
    PART_DATATYPE_2D_PLANE_BIPLANAR    =  2  #: Single color plane of a planar (2D) image. The data should be linked with the other color planes to get the complete image. The complete image consists of 2 planes. The planes of a given planar image must be placed as consecutive parts within the buffer. It is recommended to use :const:`~gentl.PIXELFORMAT_NAMESPACE_IDS.PIXELFORMAT_NAMESPACE_PFNC_32BIT` data format with this data type whenever possible.
    PART_DATATYPE_2D_PLANE_TRIPLANAR   =  3  #: Single color plane of a planar (2D) image. The data should be linked with the other color planes to get the complete image. The complete image consists of 3 planes. The planes of a given planar image must be placed as consecutive parts within the buffer. It is recommended to use :const:`~gentl.PIXELFORMAT_NAMESPACE_IDS.PIXELFORMAT_NAMESPACE_PFNC_32BIT` data format with this data type whenever possible.
    PART_DATATYPE_2D_PLANE_QUADPLANAR  =  4  #: Single color plane of a planar (2D) image. The data should be linked with the other color planes to get the complete image. The complete image consists of 4 planes. The planes of a given planar image must be placed as consecutive parts within the buffer. It is recommended to use :const:`~gentl.PIXELFORMAT_NAMESPACE_IDS.PIXELFORMAT_NAMESPACE_PFNC_32BIT` data format with this data type whenever possible.
    PART_DATATYPE_3D_IMAGE             =  5  #: 3D image (pixel coordinates). This part carries all the pixel data of given image (even if the image is represented by a single-plane pixel format, for example when transferring the depth map only). It is recommended to use :const:`~gentl.PIXELFORMAT_NAMESPACE_IDS.PIXELFORMAT_NAMESPACE_PFNC_32BIT` data format with this data type whenever possible.
    PART_DATATYPE_3D_PLANE_BIPLANAR    =  6  #: Single plane of a planar 3D image. The data should be linked with the other coordinate planes to get the complete image. The complete image consists of 2 planes. The planes of a given planar image must be placed as consecutive parts within the buffer. It is recommended to use :const:`~gentl.PIXELFORMAT_NAMESPACE_IDS.PIXELFORMAT_NAMESPACE_PFNC_32BIT` data format with this data type whenever possible.
    PART_DATATYPE_3D_PLANE_TRIPLANAR   =  7  #: Single plane of a planar 3D image. The data should be linked with the other coordinate planes to get the complete image. The complete image consists of 3 planes. The planes of a given planar image must be placed as consecutive parts within the buffer. It is recommended to use :const:`~gentl.PIXELFORMAT_NAMESPACE_IDS.PIXELFORMAT_NAMESPACE_PFNC_32BIT` data format with this data type whenever possible.
    PART_DATATYPE_3D_PLANE_QUADPLANAR  =  8  #: Single plane of a planar 3D image. The data should be linked with the other coordinate planes to get the complete image. The complete image consists of 4 planes. The planes of a given planar image must be placed as consecutive parts within the buffer. It is recommended to use :const:`~gentl.PIXELFORMAT_NAMESPACE_IDS.PIXELFORMAT_NAMESPACE_PFNC_32BIT` data format with this data type whenever possible.
    PART_DATATYPE_CONFIDENCE_MAP       =  9  #: Confidence of the individual pixel values. Expresses the level of validity of given pixel values. Confidence map is always used together with one or more additional image-based parts matching 1:1 dimension-wise. Each value in the confidence map expresses level of validity of the image pixel at matching position. The data format should be a Confidence PFNC format. It is recommended to use :const:`~gentl.PIXELFORMAT_NAMESPACE_IDS.PIXELFORMAT_NAMESPACE_PFNC_32BIT` data format with this data type whenever possible.

    PART_DATATYPE_CUSTOM_ID            = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class PORT_INFO_CMD_LIST(IntEnum):
    """
    Defines named constants to retrieve the Port module related information.
    """
    PORT_INFO_ID              = 0  #: Unique ID of the module the port references. In case of the remote device module :const:`~gentl.PORT_INFO_CMD_LIST.PORT_INFO_ID` returns the same ID as for the local device module. In case of a buffer :const:`~gentl.PORT_INFO_CMD_LIST.PORT_INFO_ID` returns the address of the buffer as hex string without the leading '0x'.
    PORT_INFO_VENDOR          = 1  #: Port vendor name. In case the underlying module has no explicit vendor the vendor of the GenTL Producer is to be used. In case of a Buffer or a Data Stream the GenTL Producer vendor and model are to be used.
    PORT_INFO_MODEL           = 2  #: Port model name. The port model references the model of the underlying module. For example if the port is for the configuration of a TLSystem module the :const:`~gentl.PORT_INFO_CMD_LIST.PORT_INFO_MODEL` returns the model of the TLSystem Module. In case the underlying module has no explicit model, the model of the GenTL Producer is to be used. So in case of a Buffer or a Data Stream the GenTL Producer model is to be used.
    PORT_INFO_TLTYPE          = 3  #: Transport layer technology that is supported.
    PORT_INFO_MODULE          = 4  #: GenTL Module the port refers to.
    PORT_INFO_LITTLE_ENDIAN   = 5  #: Flag indicating that the port's data is little endian.
    PORT_INFO_BIG_ENDIAN      = 6  #: Flag indicating that the port's data is big endian.
    PORT_INFO_ACCESS_READ     = 7  #: Flag indicating that read access is allowed.
    PORT_INFO_ACCESS_WRITE    = 8  #: Flag indicating that write access is allowed.
    PORT_INFO_ACCESS_NA       = 9  #: Flag indicating that the port is currently not available.
    PORT_INFO_ACCESS_NI       = 10  #: Flag indicating that no port is implemented. This is only valid on the Buffer module since on all other modules the port is mandatory.
    PORT_INFO_VERSION         = 11  #: Version of the port.
    PORT_INFO_PORTNAME        = 12  #: Name of the port as referenced in the XML description. This name is used to connect this port to the nodemap instance of this module.

    PORT_INFO_CUSTOM_ID       = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class URL_SCHEME_IDS(IntEnum):
    """
    Defines named constants which maps to a URL scheme.
    """
    URL_SCHEME_LOCAL         = 0  #: The XML-File is to be retrieved from the local register map.
    URL_SCHEME_HTTP          = 1  #: The XML-file can be retrieved from a webserver using the http protocol.
    URL_SCHEME_FILE          = 2  #: The XML-file can be read from the local hard disk.

    URL_SCHEME_CUSTOM_ID     = 1000  #: Starting value for custom IDs which are implementation specific.



class URL_INFO_CMD_LIST(IntEnum):
    """
    Defines named constants to retrieve the Port module information.
    """
    URL_INFO_URL                   = 0  #: A URL.
    URL_INFO_SCHEMA_VER_MAJOR      = 1  #: Major version of the schema this URL refers to.
    URL_INFO_SCHEMA_VER_MINOR      = 2  #: Minor version of the schema this URL refers to.
    URL_INFO_FILE_VER_MAJOR        = 3  #: Major version of the XML-file this URL refers to.
    URL_INFO_FILE_VER_MINOR        = 4  #: Minor version of the XML-file this URL refers to.
    URL_INFO_FILE_VER_SUBMINOR     = 5  #: Subminor version of the XML-file this URL refers to.
    URL_INFO_FILE_SHA1_HASH        = 6  #: SHA1 Hash of the XML-file this URL refers to. The size of the provided buffer is 160Bit according to the SHA1 specification.
    URL_INFO_FILE_REGISTER_ADDRESS = 7  #: Register address of the XML-File in the device's register map. In case the XML is not localy stored in the device's register map the info function should return a :const:`~gentl.GC_ERROR_LIST.GC_ERR_NOT_AVAILABLE`.
    URL_INFO_FILE_SIZE             = 8  #: File size of the XML-File in bytes.
    URL_INFO_SCHEME                = 9  #: Scheme of the URL. Possible values are defined by :class:`~gentl.URL_SCHEME_IDS`.
    URL_INFO_FILENAME              = 10  #: Filename in case the scheme of the URL is :const:`~gentl.URL_SCHEME_IDS.URL_SCHEME_FILE` or as a hint if the scheme is :const:`~gentl.URL_SCHEME_IDS.URL_SCHEME_LOCAL`.

    URL_INFO_CUSTOM_ID             = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class EVENT_TYPE_LIST(IntEnum):
    """
    Defines known event types that can be registered on certain modules.
    """
    EVENT_ERROR               = 0  #: Notification on module errors.
    EVENT_NEW_BUFFER          = 1  #: Notification on newly filled buffers.
    EVENT_FEATURE_INVALIDATE  = 2  #: Notification if a feature was changed by the GenTL Producer driver and thus needs to be invalidated in the GenICam GenApi instance using the module.
    EVENT_FEATURE_CHANGE      = 3  #: Notification if the GenTL Producer driver wants to manually set a feature in the GenICam GenApi instance using the module.
    EVENT_REMOTE_DEVICE       = 4  #: Notification if the GenTL Producer wants to inform the GenICam GenApi instance of the remote device that a GenApi compatible event was fired.
    EVENT_MODULE              = 5  #: Notification that one GenTL Producer module wants to inform the GenICam GenApi instance of this module that a GenApi compatible event was fired.

    EVENT_CUSTOM_ID           = 1000  #: Starting value for GenTL Producer custom events which are implementation specific.


class EVENT_INFO_CMD_LIST(IntEnum):
    """
    Defines named constants to retrieve the Event module realated information.
    """
    EVENT_EVENT_TYPE            = 0  #: Event type of the event handle.
    EVENT_NUM_IN_QUEUE          = 1  #: Number of events in the event data queue.
    EVENT_NUM_FIRED             = 2  #: Number of events that were fired since the registration of the event through a call to :meth:`~gentl.IEventCapableModule.register_event` method. A fired event is either still in the internal queue or already delivered to the user or discarded through :meth:`~gentl.IEventManager.flush_event_queue`.
    EVENT_SIZE_MAX              = 3  #: Maximum size in bytes of the event data provided by the event.
    EVENT_INFO_DATA_SIZE_MAX    = 4  #: Maximum size in bytes of the information output buffer.

    EVENT_INFO_CUSTOM_ID        = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


class EVENT_DATA_INFO_CMD_LIST(IntEnum):
    """
    Defines named constants to retrieve the Event Data information.
    """
    EVENT_DATA_ID           = 0  #: Attribute in the event data to identify the object or feature the event refers to. This can be, e.g., the error code for an error event or the feature name for GenApi related events.
    EVENT_DATA_VALUE        = 1  #: Defines additional data to an ID. This can be, e.g., the error message for an error event.
    EVENT_DATA_NUMID        = 2  #: Attribute in the event data to identify the object or feature the event refers to.

    EVENT_DATA_CUSTOM_ID    = 1000  #: Starting value for GenTL Producer custom IDs which are implementation specific.


GenericException = _gentl.GenericException


ErrorException = _gentl.ErrorException


NotInitializedException = _gentl.NotInitializedException


NotImplementedException = _gentl.NotImplementedException


ResourceInUseException = _gentl.ResourceInUseException


AccessDeniedException = _gentl.AccessDeniedException


InvalidHandleException = _gentl.InvalidHandleException


InvalidIdException = _gentl.InvalidIdException


NoDataException = _gentl.NoDataException


InvalidParameterException = _gentl.InvalidParameterException


IoException = _gentl.IoException


TimeoutException = _gentl.TimeoutException


AbortException = _gentl.AbortException


InvalidBufferException = _gentl.InvalidBufferException


NotAvailableException = _gentl.NotAvailableException


InvalidAddressException = _gentl.InvalidAddressException


BufferTooSmallException = _gentl.BufferTooSmallException


InvalidIndexException = _gentl.InvalidIndexException


ParsingChunkDataException = _gentl.ParsingChunkDataException


InvalidValueException = _gentl.InvalidValueException


ResourceExhaustedException = _gentl.ResourceExhaustedException


OutOfMemoryException = _gentl.OutOfMemoryException


BusyException = _gentl.BusyException


LoadLibraryException = _gentl.LoadLibraryException


ClosedException = _gentl.ClosedException

class StringList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gentl.StringList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gentl.StringList___nonzero__(self)

    def __bool__(self):
        return _gentl.StringList___bool__(self)

    def __len__(self):
        return _gentl.StringList___len__(self)

    def __getslice__(self, i, j):
        return _gentl.StringList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gentl.StringList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gentl.StringList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gentl.StringList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gentl.StringList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gentl.StringList___setitem__(self, *args)

    def pop(self):
        return _gentl.StringList_pop(self)

    def append(self, x):
        return _gentl.StringList_append(self, x)

    def empty(self):
        return _gentl.StringList_empty(self)

    def size(self):
        return _gentl.StringList_size(self)

    def swap(self, v):
        return _gentl.StringList_swap(self, v)

    def begin(self):
        return _gentl.StringList_begin(self)

    def end(self):
        return _gentl.StringList_end(self)

    def rbegin(self):
        return _gentl.StringList_rbegin(self)

    def rend(self):
        return _gentl.StringList_rend(self)

    def clear(self):
        return _gentl.StringList_clear(self)

    def get_allocator(self):
        return _gentl.StringList_get_allocator(self)

    def pop_back(self):
        return _gentl.StringList_pop_back(self)

    def erase(self, *args):
        return _gentl.StringList_erase(self, *args)

    def __init__(self, *args):
        _gentl.StringList_swiginit(self, _gentl.new_StringList(*args))

    def push_back(self, x):
        return _gentl.StringList_push_back(self, x)

    def front(self):
        return _gentl.StringList_front(self)

    def back(self):
        return _gentl.StringList_back(self)

    def assign(self, n, x):
        return _gentl.StringList_assign(self, n, x)

    def resize(self, *args):
        return _gentl.StringList_resize(self, *args)

    def insert(self, *args):
        return _gentl.StringList_insert(self, *args)

    def reserve(self, n):
        return _gentl.StringList_reserve(self, n)

    def capacity(self):
        return _gentl.StringList_capacity(self)
    __swig_destroy__ = _gentl.delete_StringList

# Register StringList in _gentl:
_gentl.StringList_swigregister(StringList)

class IEventManager(object):
    r"""

    Is an interface class that is required to be realized by the classes those handle an event and its event data.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gentl.delete_IEventManager

    def _get_handle(self):
        return _gentl.IEventManager__get_handle(self)

    def is_monitoring_event(self):
        r"""

        Returns the truth value of the given proposition: This object is monitoring the target event.

        :rtype: bool

        """
        return _gentl.IEventManager_is_monitoring_event(self)

    def unregister_event(self):
        return _gentl.IEventManager_unregister_event(self)

    def flush_event_queue(self):
        r"""

        Flushes all events in the event queue. This call empties the event data queue.

        """
        return _gentl.IEventManager_flush_event_queue(self)

    def _get_event_type(self):
        r"""

        Returns the event type of the event manager is monitoring.

        :rtype: EVENT_TYPE_LIST

        """
        return _gentl.IEventManager__get_event_type(self)

    def _get_num_in_queue(self):
        r"""

        Returns the number of event data in the event data queue.

        :rtype: int

        """
        return _gentl.IEventManager__get_num_in_queue(self)

    def _get_num_fired(self):
        r"""

        Returns the number of events those have been fired since the registration of the target event. A fired event is either still in the internal queue or already delivered to the user or discarded :meth:`~genicam.gentl.IEventManager.flush_event_queue` method.

        :rtype: int

        """
        return _gentl.IEventManager__get_num_fired(self)

    def get_event_size_max(self):
        return _gentl.IEventManager_get_event_size_max(self)

    def get_event_info_data_size_max(self):
        return _gentl.IEventManager_get_event_info_data_size_max(self)

    def _check_valid(self):
        r"""

        Returns `True` if the object has been closed. `False` otherwise.

        :rtype: bool

        """
        return _gentl.IEventManager__check_valid(self)

    handle = property(_get_handle)


    event_type = property(_get_event_type)


    num_in_queue = property(_get_num_in_queue)


    num_fired = property(_get_num_fired)


# Register IEventManager in _gentl:
_gentl.IEventManager_swigregister(IEventManager)

class EventToken(object):
    r"""

    Is used as a token to instantiate the corresponding event manager object.

    The instantiated object is used to construct EventManager classes those derived from :class:`~genicam.gentl.AbstractEventManager` class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, parent_module, event_id, h_event, h_event_src):
        _gentl.EventToken_swiginit(self, _gentl.new_EventToken(parent_module, event_id, h_event, h_event_src))
    __swig_destroy__ = _gentl.delete_EventToken

    def _get_event_type(self):
        r"""

        Returns the assigned event type.

        :rtype: EVENT_TYPE_LIST

        """
        return _gentl.EventToken__get_event_type(self)

    def _get_parent_module(self):
        r"""

        Returns its parent module.

        :rtype: IEventCapableModule

        """
        return _gentl.EventToken__get_parent_module(self)

    def _get_h_event(self):
        r"""

        Returns the event handle of the event.

        :rtype: EVENT_HANDLE

        """
        return _gentl.EventToken__get_h_event(self)

    def _get_h_event_src(self):
        r"""

        Returns the module handle which is used to unregister the target event.

        :rtype: EVENTSRC_HANDLE

        """
        return _gentl.EventToken__get_h_event_src(self)

    event_type = property(_get_event_type)


    parent_module = property(_get_parent_module)


    h_event = property(_get_h_event)


    h_event_src = property(_get_h_event_src)


# Register EventToken in _gentl:
_gentl.EventToken_swigregister(EventToken)

class AbstractEventManager(IEventManager):
    r"""

    Is a base class that is event manager classes should derive from.

    Args:
        event (EventToken): Set an :class:`~genicam.gentl.EventToken` object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gentl.delete_AbstractEventManager

    def update_event_data(self, timeout):
        r"""

        Updates its event data. Having called this method, its event data that is provided through its properties are overwritten with the latest one.

        Args:
            timeout (int): Set a timeout value in millisecond.

        Raises:
            :class:`~genicam.gentl.TimeoutException`: If any event happens within the duration defined by :data:`timeout`.

        """
        return _gentl.AbstractEventManager_update_event_data(self, timeout)

    def _get_data(self, pOutBuffer, outSize, timeout):
        return _gentl.AbstractEventManager__get_data(self, pOutBuffer, outSize, timeout)

    def _get_handle(self):
        return _gentl.AbstractEventManager__get_handle(self)

    def is_monitoring_event(self):
        r"""

        Returns the truth value of the given proposition: This object is monitoring the target event.

        :rtype: bool

        """
        return _gentl.AbstractEventManager_is_monitoring_event(self)

    def unregister_event(self):
        return _gentl.AbstractEventManager_unregister_event(self)

    def kill(self):
        return _gentl.AbstractEventManager_kill(self)

    def flush_event_queue(self):
        r"""

        Flushes all events in the event queue. This call empties the event data queue.

        """
        return _gentl.AbstractEventManager_flush_event_queue(self)

    def _get_event_type(self):
        r"""

        Returns the event type of the event manager is monitoring.

        :rtype: EVENT_TYPE_LIST

        """
        return _gentl.AbstractEventManager__get_event_type(self)

    def _get_num_in_queue(self):
        r"""

        Returns the number of event data in the event data queue.

        :rtype: int

        """
        return _gentl.AbstractEventManager__get_num_in_queue(self)

    def _get_num_fired(self):
        r"""

        Returns the number of events those have been fired since the registration of the target event. A fired event is either still in the internal queue or already delivered to the user or discarded :meth:`~genicam.gentl.IEventManager.flush_event_queue` method.

        :rtype: int

        """
        return _gentl.AbstractEventManager__get_num_fired(self)

    def get_event_size_max(self):
        return _gentl.AbstractEventManager_get_event_size_max(self)

    def get_event_info_data_size_max(self):
        return _gentl.AbstractEventManager_get_event_info_data_size_max(self)

    def _get_parent_module(self):
        r"""

        Returns the parent object that this object belongs to.

        :rtype: IEventCapableModule

        """
        return _gentl.AbstractEventManager__get_parent_module(self)

    def _check_valid(self):
        r"""

        Returns `True` if the object has been closed. `False` otherwise.

        :rtype: bool

        """
        return _gentl.AbstractEventManager__check_valid(self)

# Register AbstractEventManager in _gentl:
_gentl.AbstractEventManager_swigregister(AbstractEventManager)

class BaseEventManagerGenApiEvent(AbstractEventManager):
    r"""

    Represents the event manager class which handles :const:`~genicam.gentl.EVENT_TYPE_LIST.EVENT_FEATURE_CHANGE` event.

    Args:
        event_token (EventToken): Set an :class:`~genicam.gentl.EventToken` object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, event_token):
        _gentl.BaseEventManagerGenApiEvent_swiginit(self, _gentl.new_BaseEventManagerGenApiEvent(event_token))
    __swig_destroy__ = _gentl.delete_BaseEventManagerGenApiEvent

    def update_event_data(self, timeout):
        r"""

        Updates its event data. Having called this method, its event data that is provided through its properties are overwritten with the latest one.

        Args:
            timeout (int): Set a timeout value in millisecond.

        Raises:
            :class:`~genicam.gentl.TimeoutException`: If any event happens within the duration defined by :data:`timeout`.

        """
        return _gentl.BaseEventManagerGenApiEvent_update_event_data(self, timeout)

    def _get_event_id(self):
        r"""

        Returns string representation of the Event ID number in hexadecimal numerics with even number of digits and witout the leading ``0x``.

        :rtype: str

        """
        return _gentl.BaseEventManagerGenApiEvent__get_event_id(self)

    def _optional_data_ptr(self):
        return _gentl.BaseEventManagerGenApiEvent__optional_data_ptr(self)

    def _optional_data_size(self):
        return _gentl.BaseEventManagerGenApiEvent__optional_data_size(self)

    event_id = property(_get_event_id)


    def _get_optional_data(self):
        r"""

        Returns the data addressable through the source GenApi node map event port, beginning of the data corresponding to address 0.

        :rtype: bytes

        """
        return _gentl.BaseEventManagerGenApiEvent__get_optional_data(self)

    optional_data = property(_get_optional_data)


# Register BaseEventManagerGenApiEvent in _gentl:
_gentl.BaseEventManagerGenApiEvent_swigregister(BaseEventManagerGenApiEvent)

class EventManagerError(AbstractEventManager):
    r"""

    Represents the event manager class which handles :const:`~genicam.gentl.EVENT_TYPE_LIST.EVENT_ERROR`.

    Args:
        event_token (EventToken): Set an :class:`~genicam.gentl.EventToken` object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, event_token):
        _gentl.EventManagerError_swiginit(self, _gentl.new_EventManagerError(event_token))
    __swig_destroy__ = _gentl.delete_EventManagerError

    def update_event_data(self, timeout):
        r"""

        Updates its event data. Having called this method, its event data that is provided through its properties are overwritten with the latest one.

        Args:
            timeout (int): Set a timeout value in millisecond.

        Raises:
            :class:`~genicam.gentl.TimeoutException`: If any event happens within the duration defined by :data:`timeout`.

        """
        return _gentl.EventManagerError_update_event_data(self, timeout)

    def _get_gc_error(self):
        r"""

        Returns the error code.

        :rtype: GC_ERROR_LIST

        """
        return _gentl.EventManagerError__get_gc_error(self)

    def _get_description(self):
        r"""

        Returns description about the error.

        :rtype: str

        """
        return _gentl.EventManagerError__get_description(self)

    gc_error = property(_get_gc_error)


    description = property(_get_description)


# Register EventManagerError in _gentl:
_gentl.EventManagerError_swigregister(EventManagerError)

class EventManagerFeatureChange(AbstractEventManager):
    r"""

    Represents the event manager class which handles :const:`~genicam.gentl.EVENT_TYPE_LIST.EVENT_FEATURE_CHANGE` event.

    Args:
        event_token (EventToken): Set an :class:`~genicam.gentl.EventToken` object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, event_token):
        _gentl.EventManagerFeatureChange_swiginit(self, _gentl.new_EventManagerFeatureChange(event_token))
    __swig_destroy__ = _gentl.delete_EventManagerFeatureChange

    def update_event_data(self, timeout):
        r"""

        Updates its event data. Having called this method, its event data that is provided through its properties are overwritten with the latest one.

        Args:
            timeout (int): Set a timeout value in millisecond.

        Raises:
            :class:`~genicam.gentl.TimeoutException`: If any event happens within the duration defined by :data:`timeout`.

        """
        return _gentl.EventManagerFeatureChange_update_event_data(self, timeout)

    def _get_feature_name(self):
        r"""

        Returns the name of the feature that has changed its value.

        :rtype: str

        """
        return _gentl.EventManagerFeatureChange__get_feature_name(self)

    def _get_feature_value(self):
        r"""

        Returns the value to the feature.

        :rtype: str

        """
        return _gentl.EventManagerFeatureChange__get_feature_value(self)

    feature_name = property(_get_feature_name)


    feature_value = property(_get_feature_value)


# Register EventManagerFeatureChange in _gentl:
_gentl.EventManagerFeatureChange_swigregister(EventManagerFeatureChange)

class EventManagerFeatureInvalidate(AbstractEventManager):
    r"""

    Represents the event manager class which handles :const:`~genicam.gentl.EVENT_TYPE_LIST.EVENT_FEATURE_INVALIDATE`.

    Args:
        event_token (EventToken): Set an :class:`~genicam.gentl.EventToken` object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, event_token):
        _gentl.EventManagerFeatureInvalidate_swiginit(self, _gentl.new_EventManagerFeatureInvalidate(event_token))
    __swig_destroy__ = _gentl.delete_EventManagerFeatureInvalidate

    def update_event_data(self, timeout):
        r"""

        Updates its event data. Having called this method, its event data that is provided through its properties are overwritten with the latest one.

        Args:
            timeout (int): Set a timeout value in millisecond.

        Raises:
            :class:`~genicam.gentl.TimeoutException`: If any event happens within the duration defined by :data:`timeout`.

        """
        return _gentl.EventManagerFeatureInvalidate_update_event_data(self, timeout)

    def _get_feature_name(self):
        r"""

        Returns the name of the feature to be invalidated.

        :rtype: str

        """
        return _gentl.EventManagerFeatureInvalidate__get_feature_name(self)

    feature_name = property(_get_feature_name)


# Register EventManagerFeatureInvalidate in _gentl:
_gentl.EventManagerFeatureInvalidate_swigregister(EventManagerFeatureInvalidate)

class EventManagerModule(BaseEventManagerGenApiEvent):
    r"""

    Represents the event manager class which handles :const:`~genicam.gentl.EVENT_TYPE_LIST.EVENT_MODULE`.

    Args:
        event_token (EventToken): Set an :class:`~genicam.gentl.EventToken` object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, event_token):
        _gentl.EventManagerModule_swiginit(self, _gentl.new_EventManagerModule(event_token))
    __swig_destroy__ = _gentl.delete_EventManagerModule

# Register EventManagerModule in _gentl:
_gentl.EventManagerModule_swigregister(EventManagerModule)

class EventManagerNewBuffer(AbstractEventManager):
    r"""

    Represents the event manager class which handles :const:`~genicam.gentl.EVENT_TYPE_LIST.EVENT_NEW_BUFFER`.

    Args:
        event_token (EventToken): Set an :class:`~genicam.gentl.EventToken` object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, event_token):
        _gentl.EventManagerNewBuffer_swiginit(self, _gentl.new_EventManagerNewBuffer(event_token))
    __swig_destroy__ = _gentl.delete_EventManagerNewBuffer

    def update_event_data(self, timeout):
        r"""

        Updates its event data. Having called this method, its event data that is provided through its properties are overwritten with the latest one.

        Args:
            timeout (int): Set a timeout value in millisecond.

        Raises:
            :class:`~genicam.gentl.TimeoutException`: If any event happens within the duration defined by :data:`timeout`.

        """
        return _gentl.EventManagerNewBuffer_update_event_data(self, timeout)

    def _get_buffer(self):
        r"""

        Returns the :class:`~genicam.gentl.Buffer` object that has been filled up with acquired data.

        :rtype: Buffer

        """
        return _gentl.EventManagerNewBuffer__get_buffer(self)

    def _get_parent(self):
        r"""

        Returns the parent object that this object belongs to.

        :rtype: IEventCapableModule

        """
        return _gentl.EventManagerNewBuffer__get_parent(self)

    buffer = property(_get_buffer)


    parent = property(_get_parent)


# Register EventManagerNewBuffer in _gentl:
_gentl.EventManagerNewBuffer_swigregister(EventManagerNewBuffer)

class EventManagerRemoteDevice(BaseEventManagerGenApiEvent):
    r"""

    Represents the event manager class which handles :const:`~genicam.gentl.EVENT_TYPE_LIST.EVENT_REMOTE_DEVICE`.

    Args:
        event_token (EventToken): Set an :class:`~genicam.gentl.EventToken` object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, event_token):
        _gentl.EventManagerRemoteDevice_swiginit(self, _gentl.new_EventManagerRemoteDevice(event_token))
    __swig_destroy__ = _gentl.delete_EventManagerRemoteDevice

# Register EventManagerRemoteDevice in _gentl:
_gentl.EventManagerRemoteDevice_swigregister(EventManagerRemoteDevice)

class SEVENTNEWBUFFER(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    buffer_handle = property(_gentl.SEVENTNEWBUFFER_buffer_handle_get)
    user_data = property(_gentl.SEVENTNEWBUFFER_user_data_get)

    def __init__(self):
        _gentl.SEVENTNEWBUFFER_swiginit(self, _gentl.new_SEVENTNEWBUFFER())
    __swig_destroy__ = _gentl.delete_SEVENTNEWBUFFER

# Register SEVENTNEWBUFFER in _gentl:
_gentl.SEVENTNEWBUFFER_swigregister(SEVENTNEWBUFFER)

class LibraryManager(object):
    r"""

    Provides access to the low level functions that the GenTL standard defines.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _gentl.LibraryManager_swiginit(self, _gentl.new_LibraryManager())
    __swig_destroy__ = _gentl.delete_LibraryManager

    def load(self, path_name):
        r"""[TODO]"""
        return _gentl.LibraryManager_load(self, path_name)

    def unload(self):
        r"""[TODO]"""
        return _gentl.LibraryManager_unload(self)

    def _is_open(self):
        r"""[TODO]"""
        return _gentl.LibraryManager__is_open(self)

    def throw_if_error(self, status):
        r"""[TODO]"""
        return _gentl.LibraryManager_throw_if_error(self, status)

    def get_load_library_error_message(self):
        r"""[TODO]"""
        return _gentl.LibraryManager_get_load_library_error_message(self)

    def gc_init_lib(self):
        r"""[TODO]"""
        return _gentl.LibraryManager_gc_init_lib(self)

    def gc_close_lib(self):
        r"""[TODO]"""
        return _gentl.LibraryManager_gc_close_lib(self)

    def gc_get_last_error(self):
        r"""[TODO]"""
        return _gentl.LibraryManager_gc_get_last_error(self)

    def gc_get_last_error_message(self):
        r"""[TODO]"""
        return _gentl.LibraryManager_gc_get_last_error_message(self)

    def gc_read_port(self, h_port, address, buffer):
        r"""[TODO]"""
        return _gentl.LibraryManager_gc_read_port(self, h_port, address, buffer)

    def gc_write_port(self, h_port, address, buffer):
        r"""[TODO]"""
        return _gentl.LibraryManager_gc_write_port(self, h_port, address, buffer)

    def gc_get_port_url(self, h_port):
        r"""[TODO]"""
        return _gentl.LibraryManager_gc_get_port_url(self, h_port)

    def gc_get_num_port_urls(self, h_port):
        r"""[TODO]"""
        return _gentl.LibraryManager_gc_get_num_port_urls(self, h_port)

    def gc_get_port_url_info_buffer(self, h_port, index, info_cmd, buffer):
        r"""[TODO]"""
        return _gentl.LibraryManager_gc_get_port_url_info_buffer(self, h_port, index, info_cmd, buffer)

    def gc_register_event(self, source, info_cmd):
        r"""[TODO]"""
        return _gentl.LibraryManager_gc_register_event(self, source, info_cmd)

    def gc_unregistere_event(self, source, info_cmd):
        r"""[TODO]"""
        return _gentl.LibraryManager_gc_unregistere_event(self, source, info_cmd)

    def event_kill(self, h_event):
        r"""[TODO]"""
        return _gentl.LibraryManager_event_kill(self, h_event)

    def event_flush(self, h_event):
        r"""[TODO]"""
        return _gentl.LibraryManager_event_flush(self, h_event)

    def event_get_data(self, h_event, out_buffer, outSize, timeout):
        r"""[TODO]"""
        return _gentl.LibraryManager_event_get_data(self, h_event, out_buffer, outSize, timeout)

    def event_new_buffer_get_data(self, h_event, timeout):
        return _gentl.LibraryManager_event_new_buffer_get_data(self, h_event, timeout)

    def event_get_data_info_buffer(self, h_event, pEventBuffer, eventBufferSize, info_cmd, out_buffer, outSize):
        return _gentl.LibraryManager_event_get_data_info_buffer(self, h_event, pEventBuffer, eventBufferSize, info_cmd, out_buffer, outSize)

    def tl_open(self):
        r"""[TODO]"""
        return _gentl.LibraryManager_tl_open(self)

    def tl_close(self, h_system):
        r"""[TODO]"""
        return _gentl.LibraryManager_tl_close(self, h_system)

    def tl_get_num_interfaces(self, h_system):
        r"""[TODO]"""
        return _gentl.LibraryManager_tl_get_num_interfaces(self, h_system)

    def tl_get_interface_id(self, h_system, index):
        r"""[TODO]"""
        return _gentl.LibraryManager_tl_get_interface_id(self, h_system, index)

    def tl_open_interface(self, h_system, iface_id):
        r"""[TODO]"""
        return _gentl.LibraryManager_tl_open_interface(self, h_system, iface_id)

    def tl_update_interface_list(self, h_system, timeout):
        r"""[TODO]"""
        return _gentl.LibraryManager_tl_update_interface_list(self, h_system, timeout)

    def tl_get_interface_list(self, h_system):
        r"""[TODO]"""
        return _gentl.LibraryManager_tl_get_interface_list(self, h_system)

    def if_close(self, h_iface):
        r"""[TODO]"""
        return _gentl.LibraryManager_if_close(self, h_iface)

    def if_get_num_devices(self, h_iface):
        r"""[TODO]"""
        return _gentl.LibraryManager_if_get_num_devices(self, h_iface)

    def if_get_device_id(self, h_iface, index):
        r"""[TODO]"""
        return _gentl.LibraryManager_if_get_device_id(self, h_iface, index)

    def if_open_device(self, h_iface, device_id, open_flags):
        r"""[TODO]"""
        return _gentl.LibraryManager_if_open_device(self, h_iface, device_id, open_flags)

    def if_update_device_list(self, h_iface, timeout):
        r"""[TODO]"""
        return _gentl.LibraryManager_if_update_device_list(self, h_iface, timeout)

    def if_get_device_list(self, h_iface):
        r"""[TODO]"""
        return _gentl.LibraryManager_if_get_device_list(self, h_iface)

    def dev_get_port(self, h_device):
        r"""[TODO]"""
        return _gentl.LibraryManager_dev_get_port(self, h_device)

    def dev_get_num_data_streams(self, h_device):
        r"""[TODO]"""
        return _gentl.LibraryManager_dev_get_num_data_streams(self, h_device)

    def dev_get_data_stream_id(self, h_device, index):
        r"""[TODO]"""
        return _gentl.LibraryManager_dev_get_data_stream_id(self, h_device, index)

    def dev_get_data_stream_list(self, h_device):
        r"""[TODO]"""
        return _gentl.LibraryManager_dev_get_data_stream_list(self, h_device)

    def dev_open_data_stream(self, h_device, data_stream_id):
        r"""[TODO]"""
        return _gentl.LibraryManager_dev_open_data_stream(self, h_device, data_stream_id)

    def dev_close(self, h_device):
        r"""[TODO]"""
        return _gentl.LibraryManager_dev_close(self, h_device)

    def ds_announce_buffer(self, h_data_stream, out_buffer, user_data):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_announce_buffer(self, h_data_stream, out_buffer, user_data)

    def ds_alloc_and_announce_buffer(self, h_data_stream, size, user_data):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_alloc_and_announce_buffer(self, h_data_stream, size, user_data)

    def ds_flush_queue(self, h_data_stream, operation):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_flush_queue(self, h_data_stream, operation)

    def ds_start_acquisition(self, h_data_stream, start_flags, num_to_acquire):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_start_acquisition(self, h_data_stream, start_flags, num_to_acquire)

    def ds_stop_acquisition(self, h_data_stream, stop_flags):
        return _gentl.LibraryManager_ds_stop_acquisition(self, h_data_stream, stop_flags)

    def ds_get_buffer_id(self, h_data_stream, index):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_get_buffer_id(self, h_data_stream, index)

    def ds_close(self, h_data_stream):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_close(self, h_data_stream)

    def ds_get_num_buffer_parts(self, h_data_stream, h_buffer):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_get_num_buffer_parts(self, h_data_stream, h_buffer)

    def ds_get_buffer_chunk_data(self, h_data_stream, h_buffer, pChunkData, piNumChunks):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_get_buffer_chunk_data(self, h_data_stream, h_buffer, pChunkData, piNumChunks)

    def ds_get_buffer_part_data_offset(self, h_data_stream, h_buffer, part_index):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_get_buffer_part_data_offset(self, h_data_stream, h_buffer, part_index)

    def ds_revoke_buffer(self, h_data_stream, h_buffer):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_revoke_buffer(self, h_data_stream, h_buffer)

    def ds_revoke_producer_allocated_buffer(self, h_data_stream, h_buffer):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_revoke_producer_allocated_buffer(self, h_data_stream, h_buffer)

    def ds_queue_buffer(self, h_data_stream, h_buffer, clear_buffer=True):
        r"""[TODO]"""
        return _gentl.LibraryManager_ds_queue_buffer(self, h_data_stream, h_buffer, clear_buffer)

    def gc_get_info_int16(self, info_cmd):
        return _gentl.LibraryManager_gc_get_info_int16(self, info_cmd)

    def gc_get_info_uint16(self, info_cmd):
        return _gentl.LibraryManager_gc_get_info_uint16(self, info_cmd)

    def gc_get_info_int32(self, info_cmd):
        return _gentl.LibraryManager_gc_get_info_int32(self, info_cmd)

    def gc_get_info_uint32(self, info_cmd):
        return _gentl.LibraryManager_gc_get_info_uint32(self, info_cmd)

    def gc_get_info_int64(self, info_cmd):
        return _gentl.LibraryManager_gc_get_info_int64(self, info_cmd)

    def gc_get_info_uint64(self, info_cmd):
        return _gentl.LibraryManager_gc_get_info_uint64(self, info_cmd)

    def gc_get_info_float64(self, info_cmd):
        return _gentl.LibraryManager_gc_get_info_float64(self, info_cmd)

    def gc_get_info_bool(self, info_cmd):
        return _gentl.LibraryManager_gc_get_info_bool(self, info_cmd)

    def gc_get_info_sizet(self, info_cmd):
        return _gentl.LibraryManager_gc_get_info_sizet(self, info_cmd)

    def gc_get_info_ptr(self, info_cmd):
        return _gentl.LibraryManager_gc_get_info_ptr(self, info_cmd)

    def gc_get_info_string(self, info_cmd):
        return _gentl.LibraryManager_gc_get_info_string(self, info_cmd)

    def gc_get_port_info_int16(self, h_port, info_cmd):
        return _gentl.LibraryManager_gc_get_port_info_int16(self, h_port, info_cmd)

    def gc_get_port_info_uint16(self, h_port, info_cmd):
        return _gentl.LibraryManager_gc_get_port_info_uint16(self, h_port, info_cmd)

    def gc_get_port_info_int32(self, h_port, info_cmd):
        return _gentl.LibraryManager_gc_get_port_info_int32(self, h_port, info_cmd)

    def gc_get_port_info_uint32(self, h_port, info_cmd):
        return _gentl.LibraryManager_gc_get_port_info_uint32(self, h_port, info_cmd)

    def gc_get_port_info_int64(self, h_port, info_cmd):
        return _gentl.LibraryManager_gc_get_port_info_int64(self, h_port, info_cmd)

    def gc_get_port_info_uint64(self, h_port, info_cmd):
        return _gentl.LibraryManager_gc_get_port_info_uint64(self, h_port, info_cmd)

    def gc_get_port_info_float64(self, h_port, info_cmd):
        return _gentl.LibraryManager_gc_get_port_info_float64(self, h_port, info_cmd)

    def gc_get_port_info_bool(self, h_port, info_cmd):
        return _gentl.LibraryManager_gc_get_port_info_bool(self, h_port, info_cmd)

    def gc_get_port_info_sizet(self, h_port, info_cmd):
        return _gentl.LibraryManager_gc_get_port_info_sizet(self, h_port, info_cmd)

    def gc_get_port_info_ptr(self, h_port, info_cmd):
        return _gentl.LibraryManager_gc_get_port_info_ptr(self, h_port, info_cmd)

    def gc_get_port_info_string(self, h_port, info_cmd):
        return _gentl.LibraryManager_gc_get_port_info_string(self, h_port, info_cmd)

    def gc_get_port_url_info_int16(self, h_port, index, info_cmd):
        return _gentl.LibraryManager_gc_get_port_url_info_int16(self, h_port, index, info_cmd)

    def gc_get_port_url_info_uint16(self, h_port, index, info_cmd):
        return _gentl.LibraryManager_gc_get_port_url_info_uint16(self, h_port, index, info_cmd)

    def gc_get_port_url_info_int32(self, h_port, index, info_cmd):
        return _gentl.LibraryManager_gc_get_port_url_info_int32(self, h_port, index, info_cmd)

    def gc_get_port_url_info_uint32(self, h_port, index, info_cmd):
        return _gentl.LibraryManager_gc_get_port_url_info_uint32(self, h_port, index, info_cmd)

    def gc_get_port_url_info_int64(self, h_port, index, info_cmd):
        return _gentl.LibraryManager_gc_get_port_url_info_int64(self, h_port, index, info_cmd)

    def gc_get_port_url_info_uint64(self, h_port, index, info_cmd):
        return _gentl.LibraryManager_gc_get_port_url_info_uint64(self, h_port, index, info_cmd)

    def gc_get_port_url_info_float64(self, h_port, index, info_cmd):
        return _gentl.LibraryManager_gc_get_port_url_info_float64(self, h_port, index, info_cmd)

    def gc_get_port_url_info_bool(self, h_port, index, info_cmd):
        return _gentl.LibraryManager_gc_get_port_url_info_bool(self, h_port, index, info_cmd)

    def gc_get_port_url_info_sizet(self, h_port, index, info_cmd):
        return _gentl.LibraryManager_gc_get_port_url_info_sizet(self, h_port, index, info_cmd)

    def gc_get_port_url_info_ptr(self, h_port, index, info_cmd):
        return _gentl.LibraryManager_gc_get_port_url_info_ptr(self, h_port, index, info_cmd)

    def gc_get_port_url_info_string(self, h_port, index, info_cmd):
        return _gentl.LibraryManager_gc_get_port_url_info_string(self, h_port, index, info_cmd)

    def tl_get_interface_info_int16(self, h_system, info_cmd, iface_id):
        return _gentl.LibraryManager_tl_get_interface_info_int16(self, h_system, info_cmd, iface_id)

    def tl_get_interface_info_uint16(self, h_system, info_cmd, iface_id):
        return _gentl.LibraryManager_tl_get_interface_info_uint16(self, h_system, info_cmd, iface_id)

    def tl_get_interface_info_int32(self, h_system, info_cmd, iface_id):
        return _gentl.LibraryManager_tl_get_interface_info_int32(self, h_system, info_cmd, iface_id)

    def tl_get_interface_info_uint32(self, h_system, info_cmd, iface_id):
        return _gentl.LibraryManager_tl_get_interface_info_uint32(self, h_system, info_cmd, iface_id)

    def tl_get_interface_info_int64(self, h_system, info_cmd, iface_id):
        return _gentl.LibraryManager_tl_get_interface_info_int64(self, h_system, info_cmd, iface_id)

    def tl_get_interface_info_uint64(self, h_system, info_cmd, iface_id):
        return _gentl.LibraryManager_tl_get_interface_info_uint64(self, h_system, info_cmd, iface_id)

    def tl_get_interface_info_float64(self, h_system, info_cmd, iface_id):
        return _gentl.LibraryManager_tl_get_interface_info_float64(self, h_system, info_cmd, iface_id)

    def tl_get_interface_info_bool(self, h_system, info_cmd, iface_id):
        return _gentl.LibraryManager_tl_get_interface_info_bool(self, h_system, info_cmd, iface_id)

    def tl_get_interface_info_sizet(self, h_system, info_cmd, iface_id):
        return _gentl.LibraryManager_tl_get_interface_info_sizet(self, h_system, info_cmd, iface_id)

    def tl_get_interface_info_ptr(self, h_system, info_cmd, iface_id):
        return _gentl.LibraryManager_tl_get_interface_info_ptr(self, h_system, info_cmd, iface_id)

    def tl_get_interface_info_string(self, h_system, info_cmd, iface_id):
        return _gentl.LibraryManager_tl_get_interface_info_string(self, h_system, info_cmd, iface_id)

    def if_get_info_int16(self, h_iface, info_cmd):
        return _gentl.LibraryManager_if_get_info_int16(self, h_iface, info_cmd)

    def if_get_info_uint16(self, h_iface, info_cmd):
        return _gentl.LibraryManager_if_get_info_uint16(self, h_iface, info_cmd)

    def if_get_info_int32(self, h_iface, info_cmd):
        return _gentl.LibraryManager_if_get_info_int32(self, h_iface, info_cmd)

    def if_get_info_uint32(self, h_iface, info_cmd):
        return _gentl.LibraryManager_if_get_info_uint32(self, h_iface, info_cmd)

    def if_get_info_int64(self, h_iface, info_cmd):
        return _gentl.LibraryManager_if_get_info_int64(self, h_iface, info_cmd)

    def if_get_info_uint64(self, h_iface, info_cmd):
        return _gentl.LibraryManager_if_get_info_uint64(self, h_iface, info_cmd)

    def if_get_info_float64(self, h_iface, info_cmd):
        return _gentl.LibraryManager_if_get_info_float64(self, h_iface, info_cmd)

    def if_get_info_bool(self, h_iface, info_cmd):
        return _gentl.LibraryManager_if_get_info_bool(self, h_iface, info_cmd)

    def if_get_info_sizet(self, h_iface, info_cmd):
        return _gentl.LibraryManager_if_get_info_sizet(self, h_iface, info_cmd)

    def if_get_info_ptr(self, h_iface, info_cmd):
        return _gentl.LibraryManager_if_get_info_ptr(self, h_iface, info_cmd)

    def if_get_info_string(self, h_iface, info_cmd):
        return _gentl.LibraryManager_if_get_info_string(self, h_iface, info_cmd)

    def if_get_device_info_int16(self, h_iface, info_cmd, device_id):
        return _gentl.LibraryManager_if_get_device_info_int16(self, h_iface, info_cmd, device_id)

    def if_get_device_info_uint16(self, h_iface, info_cmd, device_id):
        return _gentl.LibraryManager_if_get_device_info_uint16(self, h_iface, info_cmd, device_id)

    def if_get_device_info_int32(self, h_iface, info_cmd, device_id):
        return _gentl.LibraryManager_if_get_device_info_int32(self, h_iface, info_cmd, device_id)

    def if_get_device_info_uint32(self, h_iface, info_cmd, device_id):
        return _gentl.LibraryManager_if_get_device_info_uint32(self, h_iface, info_cmd, device_id)

    def if_get_device_info_int64(self, h_iface, info_cmd, device_id):
        return _gentl.LibraryManager_if_get_device_info_int64(self, h_iface, info_cmd, device_id)

    def if_get_device_info_uint64(self, h_iface, info_cmd, device_id):
        return _gentl.LibraryManager_if_get_device_info_uint64(self, h_iface, info_cmd, device_id)

    def if_get_device_info_float64(self, h_iface, info_cmd, device_id):
        return _gentl.LibraryManager_if_get_device_info_float64(self, h_iface, info_cmd, device_id)

    def if_get_device_info_bool(self, h_iface, info_cmd, device_id):
        return _gentl.LibraryManager_if_get_device_info_bool(self, h_iface, info_cmd, device_id)

    def if_get_device_info_sizet(self, h_iface, info_cmd, device_id):
        return _gentl.LibraryManager_if_get_device_info_sizet(self, h_iface, info_cmd, device_id)

    def if_get_device_info_ptr(self, h_iface, info_cmd, device_id):
        return _gentl.LibraryManager_if_get_device_info_ptr(self, h_iface, info_cmd, device_id)

    def if_get_device_info_string(self, h_iface, info_cmd, device_id):
        return _gentl.LibraryManager_if_get_device_info_string(self, h_iface, info_cmd, device_id)

    def dev_get_info_int16(self, h_device, info_cmd):
        return _gentl.LibraryManager_dev_get_info_int16(self, h_device, info_cmd)

    def dev_get_info_uint16(self, h_device, info_cmd):
        return _gentl.LibraryManager_dev_get_info_uint16(self, h_device, info_cmd)

    def dev_get_info_int32(self, h_device, info_cmd):
        return _gentl.LibraryManager_dev_get_info_int32(self, h_device, info_cmd)

    def dev_get_info_uint32(self, h_device, info_cmd):
        return _gentl.LibraryManager_dev_get_info_uint32(self, h_device, info_cmd)

    def dev_get_info_int64(self, h_device, info_cmd):
        return _gentl.LibraryManager_dev_get_info_int64(self, h_device, info_cmd)

    def dev_get_info_uint64(self, h_device, info_cmd):
        return _gentl.LibraryManager_dev_get_info_uint64(self, h_device, info_cmd)

    def dev_get_info_float64(self, h_device, info_cmd):
        return _gentl.LibraryManager_dev_get_info_float64(self, h_device, info_cmd)

    def dev_get_info_bool(self, h_device, info_cmd):
        return _gentl.LibraryManager_dev_get_info_bool(self, h_device, info_cmd)

    def dev_get_info_sizet(self, h_device, info_cmd):
        return _gentl.LibraryManager_dev_get_info_sizet(self, h_device, info_cmd)

    def dev_get_info_ptr(self, h_device, info_cmd):
        return _gentl.LibraryManager_dev_get_info_ptr(self, h_device, info_cmd)

    def dev_get_info_string(self, h_device, info_cmd):
        return _gentl.LibraryManager_dev_get_info_string(self, h_device, info_cmd)

    def ds_get_info_int16(self, h_data_stream, info_cmd):
        return _gentl.LibraryManager_ds_get_info_int16(self, h_data_stream, info_cmd)

    def ds_get_info_uint16(self, h_data_stream, info_cmd):
        return _gentl.LibraryManager_ds_get_info_uint16(self, h_data_stream, info_cmd)

    def ds_get_info_int32(self, h_data_stream, info_cmd):
        return _gentl.LibraryManager_ds_get_info_int32(self, h_data_stream, info_cmd)

    def ds_get_info_uint32(self, h_data_stream, info_cmd):
        return _gentl.LibraryManager_ds_get_info_uint32(self, h_data_stream, info_cmd)

    def ds_get_info_int64(self, h_data_stream, info_cmd):
        return _gentl.LibraryManager_ds_get_info_int64(self, h_data_stream, info_cmd)

    def ds_get_info_uint64(self, h_data_stream, info_cmd):
        return _gentl.LibraryManager_ds_get_info_uint64(self, h_data_stream, info_cmd)

    def ds_get_info_float64(self, h_data_stream, info_cmd):
        return _gentl.LibraryManager_ds_get_info_float64(self, h_data_stream, info_cmd)

    def ds_get_info_bool(self, h_data_stream, info_cmd):
        return _gentl.LibraryManager_ds_get_info_bool(self, h_data_stream, info_cmd)

    def ds_get_info_sizet(self, h_data_stream, info_cmd):
        return _gentl.LibraryManager_ds_get_info_sizet(self, h_data_stream, info_cmd)

    def ds_get_info_ptr(self, h_data_stream, info_cmd):
        return _gentl.LibraryManager_ds_get_info_ptr(self, h_data_stream, info_cmd)

    def ds_get_info_string(self, h_data_stream, info_cmd):
        return _gentl.LibraryManager_ds_get_info_string(self, h_data_stream, info_cmd)

    def ds_get_buffer_info_int16(self, h_data_stream, h_buffer, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_info_int16(self, h_data_stream, h_buffer, info_cmd)

    def ds_get_buffer_info_uint16(self, h_data_stream, h_buffer, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_info_uint16(self, h_data_stream, h_buffer, info_cmd)

    def ds_get_buffer_info_int32(self, h_data_stream, h_buffer, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_info_int32(self, h_data_stream, h_buffer, info_cmd)

    def ds_get_buffer_info_uint32(self, h_data_stream, h_buffer, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_info_uint32(self, h_data_stream, h_buffer, info_cmd)

    def ds_get_buffer_info_int64(self, h_data_stream, h_buffer, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_info_int64(self, h_data_stream, h_buffer, info_cmd)

    def ds_get_buffer_info_uint64(self, h_data_stream, h_buffer, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_info_uint64(self, h_data_stream, h_buffer, info_cmd)

    def ds_get_buffer_info_float64(self, h_data_stream, h_buffer, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_info_float64(self, h_data_stream, h_buffer, info_cmd)

    def ds_get_buffer_info_bool(self, h_data_stream, h_buffer, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_info_bool(self, h_data_stream, h_buffer, info_cmd)

    def ds_get_buffer_info_sizet(self, h_data_stream, h_buffer, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_info_sizet(self, h_data_stream, h_buffer, info_cmd)

    def ds_get_buffer_info_ptr(self, h_data_stream, h_buffer, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_info_ptr(self, h_data_stream, h_buffer, info_cmd)

    def ds_get_buffer_info_string(self, h_data_stream, h_buffer, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_info_string(self, h_data_stream, h_buffer, info_cmd)

    def ds_get_buffer_part_info_int16(self, h_data_stream, h_buffer, part_index, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_part_info_int16(self, h_data_stream, h_buffer, part_index, info_cmd)

    def ds_get_buffer_part_info_uint16(self, h_data_stream, h_buffer, part_index, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_part_info_uint16(self, h_data_stream, h_buffer, part_index, info_cmd)

    def ds_get_buffer_part_info_int32(self, h_data_stream, h_buffer, part_index, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_part_info_int32(self, h_data_stream, h_buffer, part_index, info_cmd)

    def ds_get_buffer_part_info_uint32(self, h_data_stream, h_buffer, part_index, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_part_info_uint32(self, h_data_stream, h_buffer, part_index, info_cmd)

    def ds_get_buffer_part_info_int64(self, h_data_stream, h_buffer, part_index, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_part_info_int64(self, h_data_stream, h_buffer, part_index, info_cmd)

    def ds_get_buffer_part_info_uint64(self, h_data_stream, h_buffer, part_index, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_part_info_uint64(self, h_data_stream, h_buffer, part_index, info_cmd)

    def ds_get_buffer_part_info_float64(self, h_data_stream, h_buffer, part_index, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_part_info_float64(self, h_data_stream, h_buffer, part_index, info_cmd)

    def ds_get_buffer_part_info_bool(self, h_data_stream, h_buffer, part_index, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_part_info_bool(self, h_data_stream, h_buffer, part_index, info_cmd)

    def ds_get_buffer_part_info_sizet(self, h_data_stream, h_buffer, part_index, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_part_info_sizet(self, h_data_stream, h_buffer, part_index, info_cmd)

    def ds_get_buffer_part_info_ptr(self, h_data_stream, h_buffer, part_index, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_part_info_ptr(self, h_data_stream, h_buffer, part_index, info_cmd)

    def ds_get_buffer_part_info_string(self, h_data_stream, h_buffer, part_index, info_cmd):
        return _gentl.LibraryManager_ds_get_buffer_part_info_string(self, h_data_stream, h_buffer, part_index, info_cmd)

    def event_get_data_info_int16(self, h_event, pEventBuffer, eventBufferSize, info_cmd):
        return _gentl.LibraryManager_event_get_data_info_int16(self, h_event, pEventBuffer, eventBufferSize, info_cmd)

    def event_get_data_info_uint16(self, h_event, pEventBuffer, eventBufferSize, info_cmd):
        return _gentl.LibraryManager_event_get_data_info_uint16(self, h_event, pEventBuffer, eventBufferSize, info_cmd)

    def event_get_data_info_int32(self, h_event, pEventBuffer, eventBufferSize, info_cmd):
        return _gentl.LibraryManager_event_get_data_info_int32(self, h_event, pEventBuffer, eventBufferSize, info_cmd)

    def event_get_data_info_uint32(self, h_event, pEventBuffer, eventBufferSize, info_cmd):
        return _gentl.LibraryManager_event_get_data_info_uint32(self, h_event, pEventBuffer, eventBufferSize, info_cmd)

    def event_get_data_info_int64(self, h_event, pEventBuffer, eventBufferSize, info_cmd):
        return _gentl.LibraryManager_event_get_data_info_int64(self, h_event, pEventBuffer, eventBufferSize, info_cmd)

    def event_get_data_info_uint64(self, h_event, pEventBuffer, eventBufferSize, info_cmd):
        return _gentl.LibraryManager_event_get_data_info_uint64(self, h_event, pEventBuffer, eventBufferSize, info_cmd)

    def event_get_data_info_float64(self, h_event, pEventBuffer, eventBufferSize, info_cmd):
        return _gentl.LibraryManager_event_get_data_info_float64(self, h_event, pEventBuffer, eventBufferSize, info_cmd)

    def event_get_data_info_bool(self, h_event, pEventBuffer, eventBufferSize, info_cmd):
        return _gentl.LibraryManager_event_get_data_info_bool(self, h_event, pEventBuffer, eventBufferSize, info_cmd)

    def event_get_data_info_sizet(self, h_event, pEventBuffer, eventBufferSize, info_cmd):
        return _gentl.LibraryManager_event_get_data_info_sizet(self, h_event, pEventBuffer, eventBufferSize, info_cmd)

    def event_get_data_info_ptr(self, h_event, pEventBuffer, eventBufferSize, info_cmd):
        return _gentl.LibraryManager_event_get_data_info_ptr(self, h_event, pEventBuffer, eventBufferSize, info_cmd)

    def event_get_data_info_string(self, h_event, pEventBuffer, eventBufferSize, info_cmd):
        return _gentl.LibraryManager_event_get_data_info_string(self, h_event, pEventBuffer, eventBufferSize, info_cmd)

    def event_get_info_int16(self, h_event, info_cmd):
        return _gentl.LibraryManager_event_get_info_int16(self, h_event, info_cmd)

    def event_get_info_uint16(self, h_event, info_cmd):
        return _gentl.LibraryManager_event_get_info_uint16(self, h_event, info_cmd)

    def event_get_info_int32(self, h_event, info_cmd):
        return _gentl.LibraryManager_event_get_info_int32(self, h_event, info_cmd)

    def event_get_info_uint32(self, h_event, info_cmd):
        return _gentl.LibraryManager_event_get_info_uint32(self, h_event, info_cmd)

    def event_get_info_int64(self, h_event, info_cmd):
        return _gentl.LibraryManager_event_get_info_int64(self, h_event, info_cmd)

    def event_get_info_uint64(self, h_event, info_cmd):
        return _gentl.LibraryManager_event_get_info_uint64(self, h_event, info_cmd)

    def event_get_info_float64(self, h_event, info_cmd):
        return _gentl.LibraryManager_event_get_info_float64(self, h_event, info_cmd)

    def event_get_info_bool(self, h_event, info_cmd):
        return _gentl.LibraryManager_event_get_info_bool(self, h_event, info_cmd)

    def event_get_info_sizet(self, h_event, info_cmd):
        return _gentl.LibraryManager_event_get_info_sizet(self, h_event, info_cmd)

    def event_get_info_ptr(self, h_event, info_cmd):
        return _gentl.LibraryManager_event_get_info_ptr(self, h_event, info_cmd)

    def event_get_info_string(self, h_event, info_cmd):
        return _gentl.LibraryManager_event_get_info_string(self, h_event, info_cmd)

# Register LibraryManager in _gentl:
_gentl.LibraryManager_swigregister(LibraryManager)

class IEventCapableModule(object):
    r"""

    Represents the event capable module which is defined by the GenTL Standard.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gentl.delete_IEventCapableModule

    def is_open(self):
        r"""

        Returns the truth value of the following proposition: The proxy object has taken ownership of the corresponding GenTL module.

        :rtype: bool

        """
        return _gentl.IEventCapableModule_is_open(self)

    def is_valid(self):
        return _gentl.IEventCapableModule_is_valid(self)

    def register_event(self, event_id):
        r"""

        Returns an :class:`~gentl.EventToken` object which monitors an event, specified by :data:`event_id`, on the object.

        Args:
            event_id (EVENT_TYPE_LIST): Set an event that you want to monitor.

        :rtype: EventToken

        """
        return _gentl.IEventCapableModule_register_event(self, event_id)

    def _get_library_manager(self):
        return _gentl.IEventCapableModule__get_library_manager(self)

    library_manager = property(_get_library_manager)


# Register IEventCapableModule in _gentl:
_gentl.IEventCapableModule_swigregister(IEventCapableModule)

class GenTLProducer(object):
    r"""

    Is a proxy class of a GenTL Producer. You can manipulate a GenTL Producer through this object.

    To instantiate a :class:`~genicam.gentl.GenTLProducer` object, call its factory method :meth:`~genicam.gentl.GenTLProducer.create_producer`.

    This class supports ``with`` statement. It might be useful because it explicitly closes the CTI file when the object gets out of the ``with`` statement scope.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gentl.delete_GenTLProducer

    @staticmethod
    def get_compliant_version():
        return _gentl.GenTLProducer_get_compliant_version()

    @staticmethod
    def create_producer():
        r"""

        Creates and returns a :class:`~genicam.gentl.GenTLProducer` object.

        Do not forget to call its :meth:`~genicam.gentl.GenTLProducer.close` method or consider to use ``with`` statement to let :class:`~genicam.gentl.GenTLProducer` objects release the CTI file. If you didn't take any of the tricks the CTI file might be keeping held even if your :class:`~genicam.gentl.GenTLProducer` object had been already discarded.

        """
        return _gentl.GenTLProducer_create_producer()

    def open(self, path_name):
        r"""

        Opens the specified CTI file and takes ownership of it.

        Args:
            path_name (str): Set a path name to your target CTI file. For example, you may set ``/path/to/my_gentl_producer.cti``.

        """
        return _gentl.GenTLProducer_open(self, path_name)

    def close(self):
        r"""

        Closes the CTI file that you have opened through this object.

        """
        return _gentl.GenTLProducer_close(self)

    def is_open(self):
        r"""

        Returns the truth value of the following proposition: The :class:`~genicam.gentl.GenTLProducer` object has kept opening a CTI file.

        :rtype: bool

        """
        return _gentl.GenTLProducer_is_open(self)

    def is_valid(self):
        return _gentl.GenTLProducer_is_valid(self)

    def create_system(self):
        r"""

        Creates and returns the :class:`~genicam.gentl.System` object that belongs to the GenTL Producer.

        :rtype: System

        """
        return _gentl.GenTLProducer_create_system(self)

    def _get__library_manager(self):
        return _gentl.GenTLProducer__get__library_manager(self)

    def _get_path_name(self):
        return _gentl.GenTLProducer__get_path_name(self)

    _library_manager = property(_get__library_manager)


    path_name = property(_get_path_name)


    def __enter__(self):
        return self


    def __exit__(self, *args):
        if self.is_open:
            self.close()


# Register GenTLProducer in _gentl:
_gentl.GenTLProducer_swigregister(GenTLProducer)

def GenTLProducer_get_compliant_version():
    return _gentl.GenTLProducer_get_compliant_version()

def GenTLProducer_create_producer():
    r"""

    Creates and returns a :class:`~genicam.gentl.GenTLProducer` object.

    Do not forget to call its :meth:`~genicam.gentl.GenTLProducer.close` method or consider to use ``with`` statement to let :class:`~genicam.gentl.GenTLProducer` objects release the CTI file. If you didn't take any of the tricks the CTI file might be keeping held even if your :class:`~genicam.gentl.GenTLProducer` object had been already discarded.

    """
    return _gentl.GenTLProducer_create_producer()

class InterfaceInfoList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gentl.InterfaceInfoList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gentl.InterfaceInfoList___nonzero__(self)

    def __bool__(self):
        return _gentl.InterfaceInfoList___bool__(self)

    def __len__(self):
        return _gentl.InterfaceInfoList___len__(self)

    def __getslice__(self, i, j):
        return _gentl.InterfaceInfoList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gentl.InterfaceInfoList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gentl.InterfaceInfoList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gentl.InterfaceInfoList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gentl.InterfaceInfoList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gentl.InterfaceInfoList___setitem__(self, *args)

    def pop(self):
        return _gentl.InterfaceInfoList_pop(self)

    def append(self, x):
        return _gentl.InterfaceInfoList_append(self, x)

    def empty(self):
        return _gentl.InterfaceInfoList_empty(self)

    def size(self):
        return _gentl.InterfaceInfoList_size(self)

    def swap(self, v):
        return _gentl.InterfaceInfoList_swap(self, v)

    def begin(self):
        return _gentl.InterfaceInfoList_begin(self)

    def end(self):
        return _gentl.InterfaceInfoList_end(self)

    def rbegin(self):
        return _gentl.InterfaceInfoList_rbegin(self)

    def rend(self):
        return _gentl.InterfaceInfoList_rend(self)

    def clear(self):
        return _gentl.InterfaceInfoList_clear(self)

    def get_allocator(self):
        return _gentl.InterfaceInfoList_get_allocator(self)

    def pop_back(self):
        return _gentl.InterfaceInfoList_pop_back(self)

    def erase(self, *args):
        return _gentl.InterfaceInfoList_erase(self, *args)

    def __init__(self, *args):
        _gentl.InterfaceInfoList_swiginit(self, _gentl.new_InterfaceInfoList(*args))

    def push_back(self, x):
        return _gentl.InterfaceInfoList_push_back(self, x)

    def front(self):
        return _gentl.InterfaceInfoList_front(self)

    def back(self):
        return _gentl.InterfaceInfoList_back(self)

    def assign(self, n, x):
        return _gentl.InterfaceInfoList_assign(self, n, x)

    def resize(self, *args):
        return _gentl.InterfaceInfoList_resize(self, *args)

    def insert(self, *args):
        return _gentl.InterfaceInfoList_insert(self, *args)

    def reserve(self, n):
        return _gentl.InterfaceInfoList_reserve(self, n)

    def capacity(self):
        return _gentl.InterfaceInfoList_capacity(self)
    __swig_destroy__ = _gentl.delete_InterfaceInfoList

# Register InterfaceInfoList in _gentl:
_gentl.InterfaceInfoList_swigregister(InterfaceInfoList)

class System(IEventCapableModule):
    r"""

    Is a proxy class of a GenTL System module. You can manipulate a GenTL System module through this class object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, producer):
        _gentl.System_swiginit(self, _gentl.new_System(producer))
    __swig_destroy__ = _gentl.delete_System

    def open(self):
        r"""

        Let you take ownership of the GenTL System module. To moanipulate the GenTL System module, you have to take the ownership first.

        """
        return _gentl.System_open(self)

    def close(self):
        r"""

        Releases the ownership of the GenTL System module that you have taken. You can't manipulate the GenTL System module while you are not holding its ownership.

        """
        return _gentl.System_close(self)

    def is_open(self):
        r"""

        Returns the truth value of the following proposition: The :class:`~gentl.System` object has taken the ownership of the target GenTL System module.

        :rtype: bool

        """
        return _gentl.System_is_open(self)

    def is_valid(self):
        return _gentl.System_is_valid(self)

    def register_event(self, event_id):
        r"""

        Returns an :class:`~gentl.EventToken` object which monitors an event, specified by :data:`event_id`, on the object.

        Args:
            event_id (EVENT_TYPE_LIST): Set an event that you want to monitor.

        :rtype: EventToken

        """
        return _gentl.System_register_event(self, event_id)

    def update_interface_info_list(self, timeout):
        r"""

        Updates the information about the available GenTL Interface modules that belong to the GenTL System module. It will reflect the information in its :attr:`~gentl.System.interface_info_list`.

        Returns:
            bool: Returns ``True`` if there is any change on the list. ``False`` otherwise.

        """
        return _gentl.System_update_interface_info_list(self, timeout)

    def _get_port(self):
        r"""

        Returns the :class:`~gentl.Port` class object that belongs to this object.

        :rtype: Port

        """
        return _gentl.System__get_port(self)

    def _impl_get_interfaces(self):
        return _gentl.System__impl_get_interfaces(self)

    def _get__handle(self):
        return _gentl.System__get__handle(self)

    def _get_id_(self):
        return _gentl.System__get_id_(self)

    def _get_vendor(self):
        return _gentl.System__get_vendor(self)

    def _get_model(self):
        return _gentl.System__get_model(self)

    def _get_version(self):
        return _gentl.System__get_version(self)

    def _get_tl_type(self):
        return _gentl.System__get_tl_type(self)

    def _get_name(self):
        return _gentl.System__get_name(self)

    def _get_path_name(self):
        return _gentl.System__get_path_name(self)

    def _get_display_name(self):
        return _gentl.System__get_display_name(self)

    def _get_char_encoding(self):
        return _gentl.System__get_char_encoding(self)

    def _get_gentl_ver_major(self):
        return _gentl.System__get_gentl_ver_major(self)

    def _get_gentl_ver_minor(self):
        return _gentl.System__get_gentl_ver_minor(self)

    def _get_parent(self):
        return _gentl.System__get_parent(self)

    def _get_library_manager(self):
        return _gentl.System__get_library_manager(self)

    def _get_interface_info_list(self):
        r"""

        Returns the list of :class:`~gentl.InterfaceInfo` objects.

        Returns:
            (list): A :class:`list` object containing :class:`~gentl.InterfaceInfo` objects.

        """
        return _gentl.System__get_interface_info_list(self)

    interface_info_list = property(_get_interface_info_list)


    port = property(_get_port)


    _handle = property(_get__handle)


    id_ = property(_get_id_)


    vendor = property(_get_vendor)


    model = property(_get_model)


    version = property(_get_version)


    tl_type = property(_get_tl_type)


    name = property(_get_name)


    path_name = property(_get_path_name)


    display_name = property(_get_display_name)


    char_encoding = property(_get_char_encoding)


    gentl_ver_major = property(_get_gentl_ver_major)


    gentl_ver_minor = property(_get_gentl_ver_minor)


    library_manager = property(_get_library_manager)


    parent = property(_get_parent)


    def get_info_int16(self, infoCmd):
        return _gentl.System_get_info_int16(self, infoCmd)

    def get_info_uint16(self, infoCmd):
        return _gentl.System_get_info_uint16(self, infoCmd)

    def get_info_int32(self, infoCmd):
        return _gentl.System_get_info_int32(self, infoCmd)

    def get_info_uint32(self, infoCmd):
        return _gentl.System_get_info_uint32(self, infoCmd)

    def get_info_int64(self, infoCmd):
        return _gentl.System_get_info_int64(self, infoCmd)

    def get_info_uint64(self, infoCmd):
        return _gentl.System_get_info_uint64(self, infoCmd)

    def get_info_float64(self, infoCmd):
        return _gentl.System_get_info_float64(self, infoCmd)

    def get_info_bool(self, infoCmd):
        return _gentl.System_get_info_bool(self, infoCmd)

    def get_info_sizet(self, infoCmd):
        return _gentl.System_get_info_sizet(self, infoCmd)

    def get_info_ptr(self, infoCmd):
        return _gentl.System_get_info_ptr(self, infoCmd)

    def get_info_string(self, infoCmd):
        return _gentl.System_get_info_string(self, infoCmd)

# Register System in _gentl:
_gentl.System_swigregister(System)

class DeviceInfoList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gentl.DeviceInfoList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gentl.DeviceInfoList___nonzero__(self)

    def __bool__(self):
        return _gentl.DeviceInfoList___bool__(self)

    def __len__(self):
        return _gentl.DeviceInfoList___len__(self)

    def __getslice__(self, i, j):
        return _gentl.DeviceInfoList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gentl.DeviceInfoList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gentl.DeviceInfoList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gentl.DeviceInfoList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gentl.DeviceInfoList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gentl.DeviceInfoList___setitem__(self, *args)

    def pop(self):
        return _gentl.DeviceInfoList_pop(self)

    def append(self, x):
        return _gentl.DeviceInfoList_append(self, x)

    def empty(self):
        return _gentl.DeviceInfoList_empty(self)

    def size(self):
        return _gentl.DeviceInfoList_size(self)

    def swap(self, v):
        return _gentl.DeviceInfoList_swap(self, v)

    def begin(self):
        return _gentl.DeviceInfoList_begin(self)

    def end(self):
        return _gentl.DeviceInfoList_end(self)

    def rbegin(self):
        return _gentl.DeviceInfoList_rbegin(self)

    def rend(self):
        return _gentl.DeviceInfoList_rend(self)

    def clear(self):
        return _gentl.DeviceInfoList_clear(self)

    def get_allocator(self):
        return _gentl.DeviceInfoList_get_allocator(self)

    def pop_back(self):
        return _gentl.DeviceInfoList_pop_back(self)

    def erase(self, *args):
        return _gentl.DeviceInfoList_erase(self, *args)

    def __init__(self, *args):
        _gentl.DeviceInfoList_swiginit(self, _gentl.new_DeviceInfoList(*args))

    def push_back(self, x):
        return _gentl.DeviceInfoList_push_back(self, x)

    def front(self):
        return _gentl.DeviceInfoList_front(self)

    def back(self):
        return _gentl.DeviceInfoList_back(self)

    def assign(self, n, x):
        return _gentl.DeviceInfoList_assign(self, n, x)

    def resize(self, *args):
        return _gentl.DeviceInfoList_resize(self, *args)

    def insert(self, *args):
        return _gentl.DeviceInfoList_insert(self, *args)

    def reserve(self, n):
        return _gentl.DeviceInfoList_reserve(self, n)

    def capacity(self):
        return _gentl.DeviceInfoList_capacity(self)
    __swig_destroy__ = _gentl.delete_DeviceInfoList

# Register DeviceInfoList in _gentl:
_gentl.DeviceInfoList_swigregister(DeviceInfoList)

class Interface(IEventCapableModule):
    r"""

    Is a proxy class of a GenTL Interface module. You can manipulate the GenTL Interface module through this object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, transport_layer, iface_id):
        _gentl.Interface_swiginit(self, _gentl.new_Interface(transport_layer, iface_id))
    __swig_destroy__ = _gentl.delete_Interface

    def open(self):
        r"""

        Tries to take ownership of the target GenTL Interface module through the proxy object.

        """
        return _gentl.Interface_open(self)

    def close(self):
        r"""

        Releases ownership of the target GenTL module.

        """
        return _gentl.Interface_close(self)

    def is_open(self):
        r"""

        Returns the truth value of the following proposition: The proxy object has taken ownership of the corresponding GenTL module.

        :rtype: bool

        """
        return _gentl.Interface_is_open(self)

    def is_valid(self):
        return _gentl.Interface_is_valid(self)

    def register_event(self, event_id):
        r"""

        Returns an :class:`~gentl.EventToken` object which monitors an event, specified by :data:`event_id`, on the object.

        Args:
            event_id (EVENT_TYPE_LIST): Set an event that you want to monitor.

        :rtype: EventToken

        """
        return _gentl.Interface_register_event(self, event_id)

    def _get_id_(self):
        r"""

        Returns the unique ID of the :class:`~gentl.Interface` object.

        :rtype: int

        """
        return _gentl.Interface__get_id_(self)

    def _get_display_name(self):
        r"""

        Returns the user readable name of the :class:`~gentl.Interface` object.

        :rtype: int

        """
        return _gentl.Interface__get_display_name(self)

    def _get_tl_type(self):
        r"""

        Returns the transport layer technology that is supported by the :class:`~gentl.Interface` object.

        TODO: Fill rtype.

        """
        return _gentl.Interface__get_tl_type(self)

    def _get__handle(self):
        return _gentl.Interface__get__handle(self)

    def _get_port(self):
        return _gentl.Interface__get_port(self)

    def update_device_info_list(self, timeout):
        r"""

        Updates the information about the available GenTL Device modules that belong to the GenTL Interface module. It will reflect the information in its :attr:`~gentl.Interface.device_info_list`.

        Args:
            timeout (int): Set a timeout value in millisecond.

        Returns:
            (bool): ``True`` if the list content has been revised. ``False`` otherwise.

        :raises TimeoutException: If the execution expires the duration specified by :data:`timeout`.

        """
        return _gentl.Interface_update_device_info_list(self, timeout)

    def _impl_get_device_list(self):
        return _gentl.Interface__impl_get_device_list(self)

    def _get_library_manager(self):
        return _gentl.Interface__get_library_manager(self)

    def _get_parent(self):
        return _gentl.Interface__get_parent(self)

    def _get_device_info_list(self):
        r"""

        Returns a :class:`list` object containing :class:`~gentl.DeviceInfo` objects.

        Returns:
            (list): A :class:`list` object containing :class:`DeviceInfo` objects.

        """
        return _gentl.Interface__get_device_info_list(self)

    _handle = property(_get__handle)


    id_ = property(_get_id_)


    display_name = property(_get_display_name)


    tl_type = property(_get_tl_type)


    port = property(_get_port)


    device_info_list = property(_get_device_info_list)


    parent = property(_get_parent)


    library_manager = property(_get_library_manager)


    def get_info_int16(self, infoCmd):
        return _gentl.Interface_get_info_int16(self, infoCmd)

    def get_info_uint16(self, infoCmd):
        return _gentl.Interface_get_info_uint16(self, infoCmd)

    def get_info_int32(self, infoCmd):
        return _gentl.Interface_get_info_int32(self, infoCmd)

    def get_info_uint32(self, infoCmd):
        return _gentl.Interface_get_info_uint32(self, infoCmd)

    def get_info_int64(self, infoCmd):
        return _gentl.Interface_get_info_int64(self, infoCmd)

    def get_info_uint64(self, infoCmd):
        return _gentl.Interface_get_info_uint64(self, infoCmd)

    def get_info_float64(self, infoCmd):
        return _gentl.Interface_get_info_float64(self, infoCmd)

    def get_info_bool(self, infoCmd):
        return _gentl.Interface_get_info_bool(self, infoCmd)

    def get_info_sizet(self, infoCmd):
        return _gentl.Interface_get_info_sizet(self, infoCmd)

    def get_info_ptr(self, infoCmd):
        return _gentl.Interface_get_info_ptr(self, infoCmd)

    def get_info_string(self, infoCmd):
        return _gentl.Interface_get_info_string(self, infoCmd)

# Register Interface in _gentl:
_gentl.Interface_swigregister(Interface)

class InterfaceInfo(object):
    r"""

    Is a class that contains information about the corresponding GenTL Interface module.

    You can create an :class:`~gentl.Interface` object from this object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, transport_layer, iface_id):
        _gentl.InterfaceInfo_swiginit(self, _gentl.new_InterfaceInfo(transport_layer, iface_id))
    __swig_destroy__ = _gentl.delete_InterfaceInfo

    def _get_id_(self):
        r"""

        Returns the unique ID of the corresponding :class:`~gentl.Interface` object.

        :rtype: int

        """
        return _gentl.InterfaceInfo__get_id_(self)

    def _get_display_name(self):
        r"""

        Returns the user readable name of the corresponding :class:`~gentl.Interface` object.

        :rtype: int

        """
        return _gentl.InterfaceInfo__get_display_name(self)

    def _get_tl_type(self):
        r"""

        Returns the transport layer technology that is supported by the corresponding :class:`~gentl.Interface` object.

        TODO: Fill rtype.

        """
        return _gentl.InterfaceInfo__get_tl_type(self)

    def create_interface(self):
        r"""

        Creates and returns the corresponding :class:`~gentl.Interface` object.

        :rtype: Interface

        """
        return _gentl.InterfaceInfo_create_interface(self)

    def _get_parent(self):
        return _gentl.InterfaceInfo__get_parent(self)

    id_ = property(_get_id_)


    display_name = property(_get_display_name)


    tl_type = property(_get_tl_type)


    parent = property(_get_parent)


# Register InterfaceInfo in _gentl:
_gentl.InterfaceInfo_swigregister(InterfaceInfo)

class Device(IEventCapableModule):
    r"""

    Is a proxy class of GenTL Device modules. You can manipulate a GenTL Device module through this object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, iface, device_id):
        _gentl.Device_swiginit(self, _gentl.new_Device(iface, device_id))
    __swig_destroy__ = _gentl.delete_Device

    def open(self, accessFlags):
        r"""

        Let you take ownership of the GenTL Device module.

        Args:
            access_flags (DEVICE_ACCESS_FLAGS_LIST): Set a flag that you apply when opening the :class:`~genicam.gentl.Device` object.

        """
        return _gentl.Device_open(self, accessFlags)

    def close(self):
        r"""

        Releases ownership of the target GenTL module.

        """
        return _gentl.Device_close(self)

    def is_open(self):
        r"""

        Returns the truth value of the following proposition: The proxy object has taken ownership of the corresponding GenTL module.

        :rtype: bool

        """
        return _gentl.Device_is_open(self)

    def is_valid(self):
        return _gentl.Device_is_valid(self)

    def register_event(self, event_id):
        r"""

        Returns an :class:`~gentl.EventToken` object which monitors an event, specified by :data:`event_id`, on the object.

        Args:
            event_id (EVENT_TYPE_LIST): Set an event that you want to monitor.

        :rtype: EventToken

        """
        return _gentl.Device_register_event(self, event_id)

    def _get__handle(self):
        return _gentl.Device__get__handle(self)

    def _get_local_port(self):
        r"""

        Returns its local :class:`~genicam.gentl.Port` object.

        :rtype: Port

        """
        return _gentl.Device__get_local_port(self)

    def _get_remote_port(self):
        r"""

        Returns its remote :class:`~genicam.gentl.Port` object.

        :rtype: Port

        """
        return _gentl.Device__get_remote_port(self)

    def _get_id_(self):
        r"""

        Returns unique ID of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.Device__get_id_(self)

    def _get_vendor(self):
        r"""

        Returns vendor name of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.Device__get_vendor(self)

    def _get_model(self):
        r"""

        Returns model name of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.Device__get_model(self)

    def _get_tl_type(self):
        r"""

        Returns transport layer technology that is supported by the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.Device__get_tl_type(self)

    def _get_display_name(self):
        r"""

        Returns user readable name of the :class:`~genicam.gentl.Device` object. If this is not defined by the device this should be "VENDOR MODEL (ID)".

        :rtype: str

        """
        return _gentl.Device__get_display_name(self)

    def _get_access_status(self):
        r"""

        Returns access status of the :class:`~genicam.gentl.Device` object.

        :rtype: DEVICE_ACCESS_STATUS_LIST

        """
        return _gentl.Device__get_access_status(self)

    def _get_user_defined_name(self):
        r"""

        Returns user defined name of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.Device__get_user_defined_name(self)

    def _get_serial_number(self):
        r"""

        Returns serial number of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.Device__get_serial_number(self)

    def _get_version(self):
        r"""

        Returns device version of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.Device__get_version(self)

    def _get_timestamp_frequency(self):
        return _gentl.Device__get_timestamp_frequency(self)

    def _impl_get_stream_ids(self):
        return _gentl.Device__impl_get_stream_ids(self)

    def create_data_stream(self):
        r"""

        This is the factory method of the GenTL Data Stream module. Returns a :class:`~genicam.gentl.DataStream` object.

        :rtype: DataStream

        """
        return _gentl.Device_create_data_stream(self)

    def _get_library_manager(self):
        return _gentl.Device__get_library_manager(self)

    def _get_parent(self):
        return _gentl.Device__get_parent(self)

    def _get_data_stream_ids(self):
        r"""

        Returns the data stream IDs of the :class:`~genicam.gentl.DataStream` objects those belong to the :class:`~genicam.gentl.Device` object.

        Returns:
            (list): A :class:`list` object containing :class:`str` objects.

        """
        return _gentl.Device__get_data_stream_ids(self)

    _handle = property(_get__handle)


    local_port = property(_get_local_port)


    remote_port = property(_get_remote_port)


    id_ = property(_get_id_)


    vendor = property(_get_vendor)


    model = property(_get_model)


    tl_type = property(_get_tl_type)


    display_name = property(_get_display_name)


    access_status = property(_get_access_status)


    user_defined_name = property(_get_user_defined_name)


    serial_number = property(_get_serial_number)


    version = property(_get_version)


    data_stream_ids = property(_get_data_stream_ids)


    timestamp_frequency = property(_get_timestamp_frequency)


    parent = property(_get_parent)


    library_manager = property(_get_library_manager)


    def get_info_int16(self, infoCmd):
        return _gentl.Device_get_info_int16(self, infoCmd)

    def get_info_uint16(self, infoCmd):
        return _gentl.Device_get_info_uint16(self, infoCmd)

    def get_info_int32(self, infoCmd):
        return _gentl.Device_get_info_int32(self, infoCmd)

    def get_info_uint32(self, infoCmd):
        return _gentl.Device_get_info_uint32(self, infoCmd)

    def get_info_int64(self, infoCmd):
        return _gentl.Device_get_info_int64(self, infoCmd)

    def get_info_uint64(self, infoCmd):
        return _gentl.Device_get_info_uint64(self, infoCmd)

    def get_info_float64(self, infoCmd):
        return _gentl.Device_get_info_float64(self, infoCmd)

    def get_info_bool(self, infoCmd):
        return _gentl.Device_get_info_bool(self, infoCmd)

    def get_info_sizet(self, infoCmd):
        return _gentl.Device_get_info_sizet(self, infoCmd)

    def get_info_ptr(self, infoCmd):
        return _gentl.Device_get_info_ptr(self, infoCmd)

    def get_info_string(self, infoCmd):
        return _gentl.Device_get_info_string(self, infoCmd)

# Register Device in _gentl:
_gentl.Device_swigregister(Device)

class DeviceInfo(object):
    r"""

    Is a class that contains information about a GenTL Device module.

    This class can create a :class:`~genicam.gentl.Device` object. 

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, iface, device_id):
        _gentl.DeviceInfo_swiginit(self, _gentl.new_DeviceInfo(iface, device_id))
    __swig_destroy__ = _gentl.delete_DeviceInfo

    def _get_id_(self):
        r"""

        Returns unique ID of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.DeviceInfo__get_id_(self)

    def _get_vendor(self):
        r"""

        Returns device vendor name of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.DeviceInfo__get_vendor(self)

    def _get_model(self):
        r"""

        Returns device model name of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.DeviceInfo__get_model(self)

    def _get_tl_type(self):
        r"""

        Returns transport layer technology that is supported by the device.

        :rtype: str

        """
        return _gentl.DeviceInfo__get_tl_type(self)

    def _get_display_name(self):
        r"""

        Returns user readable name of the :class:`~genicam.gentl.Device` object. If this is not defined by the device this should be "VENDOR MODEL (ID)".

        :rtype: str

        """
        return _gentl.DeviceInfo__get_display_name(self)

    def _get_access_status(self):
        r"""

        Returns access status of the :class:`~genicam.gentl.Device` object.

        :rtype: DEVICE_ACCESS_STATUS_LIST

        """
        return _gentl.DeviceInfo__get_access_status(self)

    def _get_user_defined_name(self):
        r"""

        Returns user defined name of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.DeviceInfo__get_user_defined_name(self)

    def _get_serial_number(self):
        r"""

        Returns serial number of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.DeviceInfo__get_serial_number(self)

    def _get_version(self):
        r"""

        Returns device version of the :class:`~genicam.gentl.Device` object.

        :rtype: str

        """
        return _gentl.DeviceInfo__get_version(self)

    def create_device(self):
        r"""

        This is the factory method of the GenTL Device module. Returns a :class:`~genicam.gentl.Device` object.

        :rtype: Device


        """
        return _gentl.DeviceInfo_create_device(self)

    def _get_parent(self):
        return _gentl.DeviceInfo__get_parent(self)

    id_ = property(_get_id_)


    vendor = property(_get_vendor)


    model = property(_get_model)


    tl_type = property(_get_tl_type)


    display_name = property(_get_display_name)


    access_status = property(_get_access_status)


    user_defined_name = property(_get_user_defined_name)


    serial_number = property(_get_serial_number)


    version = property(_get_version)


    parent = property(_get_parent)


    def get_info_int16(self, infoCmd):
        return _gentl.DeviceInfo_get_info_int16(self, infoCmd)

    def get_info_uint16(self, infoCmd):
        return _gentl.DeviceInfo_get_info_uint16(self, infoCmd)

    def get_info_int32(self, infoCmd):
        return _gentl.DeviceInfo_get_info_int32(self, infoCmd)

    def get_info_uint32(self, infoCmd):
        return _gentl.DeviceInfo_get_info_uint32(self, infoCmd)

    def get_info_int64(self, infoCmd):
        return _gentl.DeviceInfo_get_info_int64(self, infoCmd)

    def get_info_uint64(self, infoCmd):
        return _gentl.DeviceInfo_get_info_uint64(self, infoCmd)

    def get_info_float64(self, infoCmd):
        return _gentl.DeviceInfo_get_info_float64(self, infoCmd)

    def get_info_bool(self, infoCmd):
        return _gentl.DeviceInfo_get_info_bool(self, infoCmd)

    def get_info_sizet(self, infoCmd):
        return _gentl.DeviceInfo_get_info_sizet(self, infoCmd)

    def get_info_ptr(self, infoCmd):
        return _gentl.DeviceInfo_get_info_ptr(self, infoCmd)

    def get_info_string(self, infoCmd):
        return _gentl.DeviceInfo_get_info_string(self, infoCmd)

# Register DeviceInfo in _gentl:
_gentl.DeviceInfo_swigregister(DeviceInfo)


class BufferToken():
    """
    Is used as a token to tell a :class:`~genicam.gentl.DataStream` object a raw buffer where the acquired data is filled in.

    Args:
        raw_buffer (bytes): Set a :class:`bytes` object. It is used as a buffer where the acquired data is filled in.
        context (object): Set an arbitrary object which derives from Python's built-in :class:`object` class. This object is attached to the raw buffer and a client can get it back later once the announced :class:`~genicam.gentl.Buffer` object is delivered.
    """
    def __init__(self, raw_buffer=None, context=None):
        self._items = [raw_buffer, context]

    @property
    def raw_buffer(self):
        """
        Returns the :class:`bytes` object that is being used as a raw buffer where the acquired data is filled in.

        :rtype: bytes
        """
        return self._items[0]

    @property
    def context(self):
        """
        Returns the :class:`object` object that has been tagged with the raw buffer.

        :rtype: object
        """
        return self._items[1]


class DataStream(IEventCapableModule):
    r"""

    Is a proxy class of GenTL Data Stream modules. You can manipulate a GenTL Data Stream module through this object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, device):
        _gentl.DataStream_swiginit(self, _gentl.new_DataStream(device))
    __swig_destroy__ = _gentl.delete_DataStream

    def open(self, dataStreamID):
        r"""

        Takes ownership of the GenTL Data Stream module.

        Args:
            data_stream_id (str): Set a data stream ID that you want to open. The available IDs are listed in an object that is returned by :meth:`~genicam.gentl.Device.get_data_stream_ids` property.


        """
        return _gentl.DataStream_open(self, dataStreamID)

    def close(self):
        r"""

        Releases ownership of the target GenTL module.

        """
        return _gentl.DataStream_close(self)

    def is_open(self):
        r"""

        Returns the truth value of the following proposition: The proxy object has taken ownership of the corresponding GenTL module.

        :rtype: bool

        """
        return _gentl.DataStream_is_open(self)

    def is_valid(self):
        return _gentl.DataStream_is_valid(self)

    def register_event(self, event_id):
        r"""

        Returns an :class:`~gentl.EventToken` object which monitors an event, specified by :data:`event_id`, on the object.

        Args:
            event_id (EVENT_TYPE_LIST): Set an event that you want to monitor.

        :rtype: EventToken

        """
        return _gentl.DataStream_register_event(self, event_id)

    def _get_port(self):
        return _gentl.DataStream__get_port(self)

    def announce_buffer(self, out_buffer, context):
        return _gentl.DataStream_announce_buffer(self, out_buffer, context)

    def revoke_buffer(self, buffer):
        r"""

        Removes an announced buffer from the acquisition engine. This function will free all internally allocated resources associated with this buffer. A buffer can only be revoked if it is not queued in any queue. A buffer is automatically revoked when the :class:`~genicam.gentl.DataStream` object is closed. It is up to the implementation/technology if the buffer can be revoked during an
        ongoing acquisition if it is not queued.

        Args:
            buffer (Buffer): Set a :class:`~genicam.gentl.Buffer` object to revoke.

        Returns:
            object: The context data that was given in the :meth:`~genicam.gentl.DataStream.announce_buffer` method.

        """
        return _gentl.DataStream_revoke_buffer(self, buffer)

    def queue_buffer(self, buffer, clear_buffer=True):
        r"""

        Queues a particular :class:`~genicam.gentl.Buffer` object for acquisition. A :class:`~genicam.gentl.Buffer` object can be queued for acquisition any time after the buffer was announced (before or after the acquisition has been started) if it is not currently queued. Furthermore, a buffer which is already waiting to be delivered cannot be queued for acquisition. A queued buffer cannot be revoked. The order of the delivered buffers is not necessarily the same as the order in which they have been queued.

        Args:
            buffer (Buffer): Set a :class:`~genicam.gentl.Buffer` object to queue.
            clear_buffer (bool): Set True if you want to clear the content of the raw buffer.

        """
        return _gentl.DataStream_queue_buffer(self, buffer, clear_buffer)

    def flush_buffer_queue(self, operation):
        r"""

        Flushes the by operation defined internal buffer pool or queue to another one as defined by :class:`~genicam.gentl.ACQ_QUEUE_TYPE_LIST`.

        Args:
            operation (ACQ_QUEUE_TYPE_LIST): Set a flush operation to perform as defined by :class:`~genicam.gentl.ACQ_QUEUE_TYPE_LIST`.

        """
        return _gentl.DataStream_flush_buffer_queue(self, operation)

    def start_acquisition(self, *args):
        r"""

        Starts the acquisition engine on the host. Each call to :meth:`~gent.DataStream.start_acquisition` method must be accompanied by a call to :meth:`~genicam.gentl.DataStream.stop_acquisition` method.

        Args:
            start_flags (ACQ_START_FLAGS_LIST): Set a flag that you apply when starting acquisition.
            num_to_acquire (int): Set the number of filled/delivered buffers after which the acquisition engine stops automatically. Buffers which are internally discarded or missed are not counted. If you omit passing this parameter, the acquisition continues until a call to :meth:`~genicam.gentl.DataStream.stop_acquisition` method is called.

        """
        return _gentl.DataStream_start_acquisition(self, *args)

    def stop_acquisition(self, stop_flags):
        r"""

        Stops the acquisition engine on the host. There must be a call to :meth:`~genicam.gentl.DataStream.stop_acquisition` method accompanying each call to :meth:`~genicam.gentl.DataStream.start_acquisition` method even though the stream already stopped because the number of frames to acquire was reached. This is also independent of the acquisition modes.

        Args:
            stop_flags (ACQ_STOP_FLAGS_LIST): Set a flag that you apply when stopping acquisition.

        Returns:
            GC_ERROR_LIST: An error status code of the execution.

        """
        return _gentl.DataStream_stop_acquisition(self, stop_flags)

    def _get_id_(self):
        r"""

        Returns unique ID of the :class:`~genicam.gentl.DataStream` object.

        :rtype: str

        """
        return _gentl.DataStream__get_id_(self)

    def _get_num_delivered(self):
        r"""

        Returns number of delivered buffers since last acquisition start.

        :rtype: int

        """
        return _gentl.DataStream__get_num_delivered(self)

    def _get_num_underrun(self):
        r"""

        Returns number of lost frames due to queue underrun. This number is initialized with zero at the time the stream is opened and incremented every time the data could not be acquired because there was no buffer in the input pool.

        :rtype: int

        """
        return _gentl.DataStream__get_num_underrun(self)

    def _get_num_announced(self):
        r"""

        Returns number of announced buffers.

        :rtype: int

        """
        return _gentl.DataStream__get_num_announced(self)

    def _get_num_queued(self):
        r"""

        Returns number of buffers in the input pool plus the buffer(s) currently being filled. This does not include the buffers in the output queue. The intention of this informational value is to prevent/early detect an underrun of the acquisition buffers.

        :rtype: int

        """
        return _gentl.DataStream__get_num_queued(self)

    def _get_num_awaiting_delivery(self):
        r"""

        Returns number of buffers in the output buffer queue.

        :rtype: int

        """
        return _gentl.DataStream__get_num_awaiting_delivery(self)

    def _get_num_started(self):
        r"""

        Returns number of frames started in the acquisition engine. This number is incremented every time a new buffer is started to be filled (data written to) regardless if the buffer is later delivered to the user or discarded for any reason. This number is initialized with 0 at at the time of the stream is opened. It is not reset until the stream is closed.

        :rtype: int

        """
        return _gentl.DataStream__get_num_started(self)

    def _get_payload_size(self):
        r"""

        Returns size of the expected data in bytes.

        :rtype: int

        """
        return _gentl.DataStream__get_payload_size(self)

    def is_grabbing(self):
        r"""

        Returns flag indicating whether the acquisition engine is started or not. This is independent from the acquisition status of the remote device.

        :rtype: bool

        """
        return _gentl.DataStream_is_grabbing(self)

    def defines_payload_size(self):
        r"""

        Returns flag indicating that this data stream defines a payload size independent from the remote device. If ``False`` the size of the expected payload size is to be retrieved from the remote device. If ``True`` the expected payload size is to be inquired from the :class:`~genicam.gentl.DataStream` object. In case the GenTL Producer does not support this command it is to interpreted as ``False``.

        :rtype: bool

        """
        return _gentl.DataStream_defines_payload_size(self)

    def _get_tl_type(self):
        r"""

        Returns transport layer technology that is supported.

        :rtype: str

        """
        return _gentl.DataStream__get_tl_type(self)

    def _get_num_chunks_max(self):
        r"""

        Returns maximum number of chunks to be expected in a buffer. This maximum must not change during runtime.

        :rtype: int

        Raises:
            NotAvailableException: If the :class:`~genicam.gentl.DataStream` object doesn't support the feature.

        """
        return _gentl.DataStream__get_num_chunks_max(self)

    def _get_buffer_announce_min(self):
        r"""

        Returns minimum number of buffers that clients should prepare for announcement. This minimum may change during runtime when changing parameters through the node map.

        :rtype: int

        Raises:
            NotAvailableException: If the :class:`~genicam.gentl.DataStream` object doesn't support the feature.


        """
        return _gentl.DataStream__get_buffer_announce_min(self)

    def _get_buffer_alignment(self):
        r"""

        Returns the alignment size in bytes of the buffer passed to the :meth:`~genicam.gentl.DataStream.announce_buffer` method.

        :rtype: int

        """
        return _gentl.DataStream__get_buffer_alignment(self)

    def _get__handle(self):
        return _gentl.DataStream__get__handle(self)

    def _get_library_manager(self):
        return _gentl.DataStream__get_library_manager(self)

    def _get_parent(self):
        return _gentl.DataStream__get_parent(self)

    id_ = property(_get_id_)


    num_delivered = property(_get_num_delivered)


    num_underrun = property(_get_num_underrun)


    num_announced = property(_get_num_announced)


    num_queued = property(_get_num_queued)


    num_awaiting_delivery = property(_get_num_awaiting_delivery)


    num_started = property(_get_num_started)


    payload_size = property(_get_payload_size)


    tl_type = property(_get_tl_type)


    num_chunks_max = property(_get_num_chunks_max)


    buffer_announce_min = property(_get_buffer_announce_min)


    buffer_alignment = property(_get_buffer_alignment)


    _handle = property(_get__handle)


    port = property(_get_port)


    parent = property(_get_parent)


    library_manager = property(_get_library_manager)


    def announce_buffer(self, buffer_token):
        """
        Announces a GenTL Consumer allocated buffer to the :class:`~genicam.gentl.DataStream` module to let it know the place where the acquired data is filled in.

        Note that announcing a buffer to a :class:`~genicam.gentl.DataStream` object does not mean that the buffer will be automatically queued for acquisition. This is done through a separate call to the :meth:`~genicam.gentl.DataStream.queue_buffer` method.

        Args:
            buffer_token (BufferToken): Set a :class:`~genicam.gentl.BufferToken` object which holds a :class:`bytes` object as raw buffer where you want to ask the :class:`~genicam.gentl.DataStream` object fills acquired data in.
        """
        return self._announce_buffer(buffer_token._items)


    def _announce_buffer(self, py_list):
        return _gentl.DataStream__announce_buffer(self, py_list)

    def revoke_buffer(self, buffer):
        ret = self._revoke_buffer(buffer)
        return BufferToken(raw_buffer=ret[0], context=ret[1])


    def _revoke_buffer(self, py_obj):
        return _gentl.DataStream__revoke_buffer(self, py_obj)

    def get_info_int16(self, infoCmd):
        return _gentl.DataStream_get_info_int16(self, infoCmd)

    def get_info_uint16(self, infoCmd):
        return _gentl.DataStream_get_info_uint16(self, infoCmd)

    def get_info_int32(self, infoCmd):
        return _gentl.DataStream_get_info_int32(self, infoCmd)

    def get_info_uint32(self, infoCmd):
        return _gentl.DataStream_get_info_uint32(self, infoCmd)

    def get_info_int64(self, infoCmd):
        return _gentl.DataStream_get_info_int64(self, infoCmd)

    def get_info_uint64(self, infoCmd):
        return _gentl.DataStream_get_info_uint64(self, infoCmd)

    def get_info_float64(self, infoCmd):
        return _gentl.DataStream_get_info_float64(self, infoCmd)

    def get_info_bool(self, infoCmd):
        return _gentl.DataStream_get_info_bool(self, infoCmd)

    def get_info_sizet(self, infoCmd):
        return _gentl.DataStream_get_info_sizet(self, infoCmd)

    def get_info_ptr(self, infoCmd):
        return _gentl.DataStream_get_info_ptr(self, infoCmd)

    def get_info_string(self, infoCmd):
        return _gentl.DataStream_get_info_string(self, infoCmd)

# Register DataStream in _gentl:
_gentl.DataStream_swigregister(DataStream)

class Parts(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gentl.Parts_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gentl.Parts___nonzero__(self)

    def __bool__(self):
        return _gentl.Parts___bool__(self)

    def __len__(self):
        return _gentl.Parts___len__(self)

    def __getslice__(self, i, j):
        return _gentl.Parts___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gentl.Parts___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gentl.Parts___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gentl.Parts___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gentl.Parts___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gentl.Parts___setitem__(self, *args)

    def pop(self):
        return _gentl.Parts_pop(self)

    def append(self, x):
        return _gentl.Parts_append(self, x)

    def empty(self):
        return _gentl.Parts_empty(self)

    def size(self):
        return _gentl.Parts_size(self)

    def swap(self, v):
        return _gentl.Parts_swap(self, v)

    def begin(self):
        return _gentl.Parts_begin(self)

    def end(self):
        return _gentl.Parts_end(self)

    def rbegin(self):
        return _gentl.Parts_rbegin(self)

    def rend(self):
        return _gentl.Parts_rend(self)

    def clear(self):
        return _gentl.Parts_clear(self)

    def get_allocator(self):
        return _gentl.Parts_get_allocator(self)

    def pop_back(self):
        return _gentl.Parts_pop_back(self)

    def erase(self, *args):
        return _gentl.Parts_erase(self, *args)

    def __init__(self, *args):
        _gentl.Parts_swiginit(self, _gentl.new_Parts(*args))

    def push_back(self, x):
        return _gentl.Parts_push_back(self, x)

    def front(self):
        return _gentl.Parts_front(self)

    def back(self):
        return _gentl.Parts_back(self)

    def assign(self, n, x):
        return _gentl.Parts_assign(self, n, x)

    def resize(self, *args):
        return _gentl.Parts_resize(self, *args)

    def insert(self, *args):
        return _gentl.Parts_insert(self, *args)

    def reserve(self, n):
        return _gentl.Parts_reserve(self, n)

    def capacity(self):
        return _gentl.Parts_capacity(self)
    __swig_destroy__ = _gentl.delete_Parts

# Register Parts in _gentl:
_gentl.Parts_swigregister(Parts)

class Buffer(object):
    r"""

    Is a proxy class of GenTL Buffer modules. You can manipulate a GenTL Buffer module through this object.

    A :class:`~genicam.gentl.Buffer` object is created when a raw buffer is announced on a :class:`~genicam.gentl.DataStream` object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, data_stream, h_buffer, context):
        _gentl.Buffer_swiginit(self, _gentl.new_Buffer(data_stream, h_buffer, context))
    __swig_destroy__ = _gentl.delete_Buffer

    def _get__handle(self):
        return _gentl.Buffer__get__handle(self)

    def _get__parent_handle(self):
        return _gentl.Buffer__get__parent_handle(self)

    def _get__context(self):
        return _gentl.Buffer__get__context(self)

    def _get_payload_type(self):
        r"""

        Returns the payload type of the :class:`~genicam.gentl.Buffer` object that is defined as an entry of :class:`~genicam.gentl.PAYLOADTYPE_INFO_IDS`.

        :rtype: PAYLOADTYPE_INFO_IDS

        """
        return _gentl.Buffer__get_payload_type(self)

    def _get__base(self):
        return _gentl.Buffer__get__base(self)

    def _get_size(self):
        return _gentl.Buffer__get_size(self)

    def _get_timestamp(self):
        r"""

        Returns the timestamp that has been stamped on the raw buffer.

        :rtype: int

        """
        return _gentl.Buffer__get_timestamp(self)

    def has_new_data(self):
        r"""

        Returns the truth value of the given proposition: The :class:`~genicam.gentl.Buffer` object has one or more newly delivered data.

        :rtype: bool

        """
        return _gentl.Buffer_has_new_data(self)

    def has_been_queued(self):
        r"""

        Returns the truth value of the given proposition: The :class:`~genicam.gentl.Buffer` object has been queued in a :class:`~genicam.gentl.DataStream` object.

        :rtype: bool

        """
        return _gentl.Buffer_has_been_queued(self)

    def is_acquiring(self):
        r"""

        Returns the truth value of the given proposition: The :class:`~genicam.gentl.Buffer` object is currently being filled with data.

        :rtype: bool

        """
        return _gentl.Buffer_is_acquiring(self)

    def _is_incomplete(self):
        r"""

        Returns the truth value of the given proposition: The :class:`~genicam.gentl.Buffer` object was filled but an error occurred during that process.

        :rtype: bool

        """
        return _gentl.Buffer__is_incomplete(self)

    def _get_tl_type(self):
        r"""

        Returns the transport layer technology that is supported by the :class:`~genicam.gentl.Buffer` object.

        :rtype: str

        """
        return _gentl.Buffer__get_tl_type(self)

    def is_containing_chunk_data(self):
        return _gentl.Buffer_is_containing_chunk_data(self)

    def contains_image(self):
        return _gentl.Buffer_contains_image(self)

    def _get_width(self):
        return _gentl.Buffer__get_width(self)

    def _get_height(self):
        return _gentl.Buffer__get_height(self)

    def _get_offset_x(self):
        return _gentl.Buffer__get_offset_x(self)

    def _get_offset_y(self):
        return _gentl.Buffer__get_offset_y(self)

    def _get_padding_x(self):
        return _gentl.Buffer__get_padding_x(self)

    def _get_padding_y(self):
        return _gentl.Buffer__get_padding_y(self)

    def _get_pixel_format(self):
        return _gentl.Buffer__get_pixel_format(self)

    def _get_pixel_format_name_space(self):
        return _gentl.Buffer__get_pixel_format_name_space(self)

    def _get_frame_id(self):
        return _gentl.Buffer__get_frame_id(self)

    def _get_num_chunks(self):
        return _gentl.Buffer__get_num_chunks(self)

    def _get_single_chunk_data_list(self):
        return _gentl.Buffer__get_single_chunk_data_list(self)

    def _get_delivered_image_height(self):
        return _gentl.Buffer__get_delivered_image_height(self)

    def _get_delivered_chunk_payload_size(self):
        return _gentl.Buffer__get_delivered_chunk_payload_size(self)

    def _get_chunk_layout_id(self):
        return _gentl.Buffer__get_chunk_layout_id(self)

    def _get_file_name(self):
        return _gentl.Buffer__get_file_name(self)

    def _get_pixel_endianness(self):
        return _gentl.Buffer__get_pixel_endianness(self)

    def _get_data_size(self):
        return _gentl.Buffer__get_data_size(self)

    def _get_timestamp_ns(self):
        return _gentl.Buffer__get_timestamp_ns(self)

    def has_received_larger_payload(self):
        return _gentl.Buffer_has_received_larger_payload(self)

    def _get_size_filled(self):
        return _gentl.Buffer__get_size_filled(self)

    def _get_image_offset(self):
        return _gentl.Buffer__get_image_offset(self)

    def _get_parent(self):
        return _gentl.Buffer__get_parent(self)

    def _get__num_buffer_parts(self):
        r"""

        Returns the number of independent data parts in the :class:`~genicam.gentl.Buffer` object.

        :rtype: int

        """
        return _gentl.Buffer__get__num_buffer_parts(self)

    def _get_parts(self):
        r"""

        Returns a :class:`list` object containing :class:`~genicam.gentl.Part` objects. If the target doesn't support multi-part buffer, the list object is not ``None`` but the length will be zero.

        Returns:
            (list): A :class:`list` object containing :class:`~genicam.gentl.Part` objects.

        """
        return _gentl.Buffer__get_parts(self)

    def clear(self):
        r"""

        Clears the content of the raw buffer that has been attached to the :class:`~genicam.gentl.Buffer` object. Every data element of the raw buffer will be overwritten with value 0.

        """
        return _gentl.Buffer_clear(self)

    def _get_library_manager(self):
        return _gentl.Buffer__get_library_manager(self)

    _handle = property(_get__handle)


    _parent_handle = property(_get__parent_handle)


    _context = property(_get__context)


    size = property(_get_size)


    payload_type = property(_get_payload_type)


    _num_buffer_parts = property(_get__num_buffer_parts)


    _base = property(_get__base)


    timestamp = property(_get_timestamp)


    tl_type = property(_get_tl_type)


    width = property(_get_width)


    height = property(_get_height)


    offset_x = property(_get_offset_x)


    offset_y = property(_get_offset_y)


    padding_x = property(_get_padding_x)


    padding_y = property(_get_padding_y)


    pixel_format = property(_get_pixel_format)


    pixel_format_name_space = property(_get_pixel_format_name_space)


    frame_id = property(_get_frame_id)


    delivered_image_height = property(_get_delivered_image_height)


    delivered_chunk_payload_size = property(_get_delivered_chunk_payload_size)


    chunk_layout_id = property(_get_chunk_layout_id)


    file_name = property(_get_file_name)


    pixel_endianness = property(_get_pixel_endianness)


    data_size = property(_get_data_size)


    timestamp_ns = property(_get_timestamp_ns)


    size_filled = property(_get_size_filled)


    image_offset = property(_get_image_offset)


    parts = property(_get_parts)


    library_manager = property(_get_library_manager)


    num_chunks = property(_get_num_chunks)


    parent = property(_get_parent)


    def is_complete(self):
        return _gentl.Buffer_is_complete(self)

    def _get_raw_buffer(self):
        r"""

        Returns the :class:`bytes` object that is being used as the raw buffer where data is delivered from the target transmitter device.

        :rtype: bytes

        """
        return _gentl.Buffer__get_raw_buffer(self)

    raw_buffer = property(_get_raw_buffer)


    def _get_context(self):
        return _gentl.Buffer__get_context(self)

    context = property(_get_context)


    def _get_chunk_data_info_list(self):
        return _gentl.Buffer__get_chunk_data_info_list(self)

    chunk_data_info_list = property(_get_chunk_data_info_list)


    def get_info_int16(self, infoCmd):
        return _gentl.Buffer_get_info_int16(self, infoCmd)

    def get_info_uint16(self, infoCmd):
        return _gentl.Buffer_get_info_uint16(self, infoCmd)

    def get_info_int32(self, infoCmd):
        return _gentl.Buffer_get_info_int32(self, infoCmd)

    def get_info_uint32(self, infoCmd):
        return _gentl.Buffer_get_info_uint32(self, infoCmd)

    def get_info_int64(self, infoCmd):
        return _gentl.Buffer_get_info_int64(self, infoCmd)

    def get_info_uint64(self, infoCmd):
        return _gentl.Buffer_get_info_uint64(self, infoCmd)

    def get_info_float64(self, infoCmd):
        return _gentl.Buffer_get_info_float64(self, infoCmd)

    def get_info_bool(self, infoCmd):
        return _gentl.Buffer_get_info_bool(self, infoCmd)

    def get_info_sizet(self, infoCmd):
        return _gentl.Buffer_get_info_sizet(self, infoCmd)

    def get_info_ptr(self, infoCmd):
        return _gentl.Buffer_get_info_ptr(self, infoCmd)

    def get_info_string(self, infoCmd):
        return _gentl.Buffer_get_info_string(self, infoCmd)

# Register Buffer in _gentl:
_gentl.Buffer_swigregister(Buffer)

class Part(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, buffer, part_index):
        _gentl.Part_swiginit(self, _gentl.new_Part(buffer, part_index))
    __swig_destroy__ = _gentl.delete_Part

    def _get_data_offset(self):
        r"""

        Returns the offset address to the specified buffer part of the :class:`~genicam.gentl.Buffer` object.

        :rtype: int

        """
        return _gentl.Part__get_data_offset(self)

    def _get_data_size(self):
        r"""

        Returns the size of the data intended to be written to the buffer last time it has been filled. This value is reset to 0 when the buffer is placed into the input buffer pool. If the buffer is incomplete the number still reports the full size of the original data including the lost parts. If the buffer is complete, the number equals to the size reported through :const:`~genicam.gentl.BUFFER_INFO_CMD_LIST.BUFFER_INFO_SIZE_FILLED`.

        :rtype: int

        """
        return _gentl.Part__get_data_size(self)

    def _get_data_type(self):
        r"""

        Returns the type of the data in given part. This information refers to the constants defined by :class:`~genicam.gentl.PARTDATATYPE_IDS`.

        :rtype: PARTDATATYPE_IDS

        """
        return _gentl.Part__get_data_type(self)

    def _get_data_format(self):
        r"""

        Returns the format of the individual items (such as pixels) in the buffer part. The interpretation of the format is specific to every data type (:const:`~genicam.gentl.BUFFER_PART_INFO_CMD_LIST.BUFFER_PART_INFO_DATA_TYPE`), as specified in definitions of individual :class:`~genicam.gentl.PARTDATATYPE_IDS`. The actual meaning of the data format depends on the namespace the format belongs to which can be inquired using the :const:`~genicam.gentl.BUFFER_PART_INFO_CMD_LIST.BUFFER_PART_INFO_DATA_FORMAT_NAMESPACE` command (although for the standard :class:`~genicam.gentl.PARTDATATYPE_IDS` a recommended data format namespace is always specified).

        :rtype: int

        """
        return _gentl.Part__get_data_format(self)

    def _get_data_format_namespace(self):
        r"""

        Returns the format of the individual items (such as pixels) in the buffer part. The interpretation of the format is specific to every data type (:const:`~genicam.gentl.BUFFER_PART_INFO_CMD_LIST.BUFFER_PART_INFO_DATA_TYPE`), as specified in definitions of individual :class:`~genicam.gentl.PARTDATATYPE_IDS`. The actual meaning of the data format depends on the namespace the format belongs to which can be inquired using the :const:`~genicam.gentl.BUFFER_PART_INFO_CMD_LIST.BUFFER_PART_INFO_DATA_FORMAT_NAMESPACE` command (although for the standard :class:`~genicam.gentl.PARTDATATYPE_IDS` a recommended data format namespace is always specified).

        Returns:
            PIXELFORMAT_NAMESPACE_IDS: Information refers to the constants defined by :class:`~genicam.gentl.PIXELFORMAT_NAMESPACE_IDS` to allow interpretation of :class:`~genicam.gentl.BUFFER_PART_INFO_CMD_LIST.BUFFER_PART_INFO_DATA_FORMAT`.

        """
        return _gentl.Part__get_data_format_namespace(self)

    def _get_width(self):
        r"""

        Returns the width of the data in the buffer in number of pixels. This information refers for example to the width entry in the GigE Vision image stream data leader. For other technologies this is to be implemented accordingly.

        :rtype: int

        """
        return _gentl.Part__get_width(self)

    def _get_height(self):
        r"""

        Returns the height of the data in the buffer in number of pixels as configured. For variable size images this is the maximum height of the buffer. For example this information refers to the height entry in the GigE Vision image stream data leader. For other technologies this is to be implemented accordingly.

        :rtype: int

        """
        return _gentl.Part__get_height(self)

    def _get_x_offset(self):
        r"""

        Returns XOffset of the data in the buffer in number of pixels from the image origin to handle areas of interest. This information refers for example to the information provided in the GigE Vision image stream  data leader. For other technologies this is to be implemented accordingly.

        :rtype: int

        """
        return _gentl.Part__get_x_offset(self)

    def _get_y_offset(self):
        r"""

        Returns YOffset of the data in the buffer in number of lines from the image origin to handle areas of interest. This information refers for example to the information provided in the GigE Vision image stream data leader. For other technologies this is to be implemented accordingly.

        :rtype: int

        """
        return _gentl.Part__get_y_offset(self)

    def _get_x_padding(self):
        r"""

        Returns XPadding of the data in the buffer in number of bytes. This information refers for example to the information provided in the GigE Vision image stream data leader. For other technologies this is may be implemented accordingly.

        :rtype: int

        """
        return _gentl.Part__get_x_padding(self)

    def _get_source_id(self):
        r"""

        Returns the identifier allowing to group data parts belonging to the same source (usually corresponding with the SourceSelector/ChunkSourceID features from SFNC). Parts marked with the same source_id can be mapped together. Parts carrying data from different ROI's of the same source would typically be marked with the same source_id. It is not mandatory that source_id's within a given buffer make a contiguous sequence of  numbers starting with zero.

        Note: for example with a dual-source 3D camera, the buffer can contain data parts carrying the 3D data and Confidence data corresponding to both of the two different sources. In this case the source ID helps to match the 3D and Confidence parts belonging together. This information refers for example to the information provided in the GigE Vision image stream multi-part data leader.

        :rtype: int

        """
        return _gentl.Part__get_source_id(self)

    def _get_delivered_image_height(self):
        r"""

        Returns the number of lines in the current buffer as delivered by the transport mechanism. For area scan type images this is usually the number of lines configured in the device. For variable size line scan images this number may be lower than the configured image height. This information refers for example to the information provided in the GigE Vision image stream data trailer. For other technologies this is to be implemented accordingly.

        :rtype: int

        """
        return _gentl.Part__get_delivered_image_height(self)

    data_offset = property(_get_data_offset)


    data_size = property(_get_data_size)


    data_type = property(_get_data_type)


    data_format = property(_get_data_format)


    data_format_namespace = property(_get_data_format_namespace)


    width = property(_get_width)


    height = property(_get_height)


    x_offset = property(_get_x_offset)


    y_offset = property(_get_y_offset)


    x_padding = property(_get_x_padding)


    source_id = property(_get_source_id)


    delivered_image_height = property(_get_delivered_image_height)


    def get_info_int16(self, infoCmd):
        return _gentl.Part_get_info_int16(self, infoCmd)

    def get_info_uint16(self, infoCmd):
        return _gentl.Part_get_info_uint16(self, infoCmd)

    def get_info_int32(self, infoCmd):
        return _gentl.Part_get_info_int32(self, infoCmd)

    def get_info_uint32(self, infoCmd):
        return _gentl.Part_get_info_uint32(self, infoCmd)

    def get_info_int64(self, infoCmd):
        return _gentl.Part_get_info_int64(self, infoCmd)

    def get_info_uint64(self, infoCmd):
        return _gentl.Part_get_info_uint64(self, infoCmd)

    def get_info_float64(self, infoCmd):
        return _gentl.Part_get_info_float64(self, infoCmd)

    def get_info_bool(self, infoCmd):
        return _gentl.Part_get_info_bool(self, infoCmd)

    def get_info_sizet(self, infoCmd):
        return _gentl.Part_get_info_sizet(self, infoCmd)

    def get_info_ptr(self, infoCmd):
        return _gentl.Part_get_info_ptr(self, infoCmd)

    def get_info_string(self, infoCmd):
        return _gentl.Part_get_info_string(self, infoCmd)

# Register Part in _gentl:
_gentl.Part_swigregister(Part)

class URLInfoList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gentl.URLInfoList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gentl.URLInfoList___nonzero__(self)

    def __bool__(self):
        return _gentl.URLInfoList___bool__(self)

    def __len__(self):
        return _gentl.URLInfoList___len__(self)

    def __getslice__(self, i, j):
        return _gentl.URLInfoList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gentl.URLInfoList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gentl.URLInfoList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gentl.URLInfoList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gentl.URLInfoList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gentl.URLInfoList___setitem__(self, *args)

    def pop(self):
        return _gentl.URLInfoList_pop(self)

    def append(self, x):
        return _gentl.URLInfoList_append(self, x)

    def empty(self):
        return _gentl.URLInfoList_empty(self)

    def size(self):
        return _gentl.URLInfoList_size(self)

    def swap(self, v):
        return _gentl.URLInfoList_swap(self, v)

    def begin(self):
        return _gentl.URLInfoList_begin(self)

    def end(self):
        return _gentl.URLInfoList_end(self)

    def rbegin(self):
        return _gentl.URLInfoList_rbegin(self)

    def rend(self):
        return _gentl.URLInfoList_rend(self)

    def clear(self):
        return _gentl.URLInfoList_clear(self)

    def get_allocator(self):
        return _gentl.URLInfoList_get_allocator(self)

    def pop_back(self):
        return _gentl.URLInfoList_pop_back(self)

    def erase(self, *args):
        return _gentl.URLInfoList_erase(self, *args)

    def __init__(self, *args):
        _gentl.URLInfoList_swiginit(self, _gentl.new_URLInfoList(*args))

    def push_back(self, x):
        return _gentl.URLInfoList_push_back(self, x)

    def front(self):
        return _gentl.URLInfoList_front(self)

    def back(self):
        return _gentl.URLInfoList_back(self)

    def assign(self, n, x):
        return _gentl.URLInfoList_assign(self, n, x)

    def resize(self, *args):
        return _gentl.URLInfoList_resize(self, *args)

    def insert(self, *args):
        return _gentl.URLInfoList_insert(self, *args)

    def reserve(self, n):
        return _gentl.URLInfoList_reserve(self, n)

    def capacity(self):
        return _gentl.URLInfoList_capacity(self)
    __swig_destroy__ = _gentl.delete_URLInfoList

# Register URLInfoList in _gentl:
_gentl.URLInfoList_swigregister(URLInfoList)

class Port(object):
    r"""

    Represents the Port module which is defined by the GenTL Standard.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gentl.delete_Port

    def _check_valid(self):
        r"""

        [OPEN]

        """
        return _gentl.Port__check_valid(self)

    def _get_handle(self):
        return _gentl.Port__get_handle(self)

    def read(self, address, buffer):
        r"""

        Read an arbitrary size of data on the port.

        Args:
            address (int): Set a start address to read.
            size (int): Set a size in bytes to read.

        Returns:
            bytes: 

        """
        return _gentl.Port_read(self, address, buffer)

    def write(self, address, buffer):
        r"""

        Write an arbitrary size of data on the port.

        Args:
            address (int): Set a start address to write data.
            buffer (bytes): Set an arbitrary size of data to write.

        """
        return _gentl.Port_write(self, address, buffer)

    def _get__num_port_urls(self):
        r"""

        Returns the number of URLs for this port.

        :rtype: int

        """
        return _gentl.Port__get__num_port_urls(self)

    def _get_id_(self):
        r"""

        Returns the unique ID of the :class:`~gentl.Port` object.

        :rtype: str

        """
        return _gentl.Port__get_id_(self)

    def _get_vendor(self):
        r"""

        Returns the port vendor name of the :class:`~gentl.Port` object.

        :rtype: str

        """
        return _gentl.Port__get_vendor(self)

    def _get_model(self):
        r"""

        Returns the port model name of the :class:`~gentl.Port` object.

        :rtype: str

        """
        return _gentl.Port__get_model(self)

    def _get_tl_type(self):
        r"""

        Returns the transport layer technology that is supported by the :class:`~gentl.Port` object.

        :rtype: str

        """
        return _gentl.Port__get_tl_type(self)

    def _get_module(self):
        r"""

        Returns the GenTL Module the :class:`~gentl.Port` object refers to.

        :rtype: str

        """
        return _gentl.Port__get_module(self)

    def is_little_endian(self):
        r"""

        Returns the flag indicating that the port's data is little endian.

        :rtype: bool

        """
        return _gentl.Port_is_little_endian(self)

    def is_big_endian(self):
        r"""

        Returns the flag indicating that the port's data is big endian.

        :rtype: bool

        """
        return _gentl.Port_is_big_endian(self)

    def supports_read_access(self):
        r"""

        Returns the flag indicating that read access is allowed.

        :rtype: bool

        """
        return _gentl.Port_supports_read_access(self)

    def supports_write_access(self):
        r"""

        Returns the flag indicating that write access is allowed.

        :rtype: bool

        """
        return _gentl.Port_supports_write_access(self)

    def _is_access_na(self):
        r"""

        Returns the flag indicating that the port is currently not available.

        :rtype: bool

        """
        return _gentl.Port__is_access_na(self)

    def _is_access_ni(self):
        r"""

        Returns the flag indicating that no port is implemented.

        :rtype: bool

        """
        return _gentl.Port__is_access_ni(self)

    def _get_version(self):
        r"""

        Returns the version of the :class:`~gentl.Port` object.

        :rtype: str

        """
        return _gentl.Port__get_version(self)

    def _get_name(self):
        r"""

        Returns the name of the :class:`~gentl.Port` object as referenced in the XML description.

        :rtype: str

        """
        return _gentl.Port__get_name(self)

    def _get_url_info_list(self):
        r"""

        Returns a :class:`list` object containing :class:`~gentl.URLInfo` objects.


        Returns:
            (list): A :class:`list` object containing :class:`~gentl.URLInfo` objects.

        """
        return _gentl.Port__get_url_info_list(self)

    def _get_library_manager(self):
        return _gentl.Port__get_library_manager(self)

    handle = property(_get_handle)


    _num_port_urls = property(_get__num_port_urls)


    id_ = property(_get_id_)


    vendor = property(_get_vendor)


    model = property(_get_model)


    tl_type = property(_get_tl_type)


    module = property(_get_module)


    version = property(_get_version)


    name = property(_get_name)


    url_info_list = property(_get_url_info_list)


    library_manager = property(_get_library_manager)


    def is_available(self):
        return _gentl.Port_is_available(self)

    def has_been_implemented(self):
        return _gentl.Port_has_been_implemented(self)

    def get_info_int16(self, infoCmd):
        return _gentl.Port_get_info_int16(self, infoCmd)

    def get_info_uint16(self, infoCmd):
        return _gentl.Port_get_info_uint16(self, infoCmd)

    def get_info_int32(self, infoCmd):
        return _gentl.Port_get_info_int32(self, infoCmd)

    def get_info_uint32(self, infoCmd):
        return _gentl.Port_get_info_uint32(self, infoCmd)

    def get_info_int64(self, infoCmd):
        return _gentl.Port_get_info_int64(self, infoCmd)

    def get_info_uint64(self, infoCmd):
        return _gentl.Port_get_info_uint64(self, infoCmd)

    def get_info_float64(self, infoCmd):
        return _gentl.Port_get_info_float64(self, infoCmd)

    def get_info_bool(self, infoCmd):
        return _gentl.Port_get_info_bool(self, infoCmd)

    def get_info_sizet(self, infoCmd):
        return _gentl.Port_get_info_sizet(self, infoCmd)

    def get_info_ptr(self, infoCmd):
        return _gentl.Port_get_info_ptr(self, infoCmd)

    def get_info_string(self, infoCmd):
        return _gentl.Port_get_info_string(self, infoCmd)

# Register Port in _gentl:
_gentl.Port_swigregister(Port)

class URLInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, port, url_index):
        _gentl.URLInfo_swiginit(self, _gentl.new_URLInfo(port, url_index))
    __swig_destroy__ = _gentl.delete_URLInfo

    def _get_url(self):
        r"""

        Returns the URL of the specified index.

        :rtype: str

        """
        return _gentl.URLInfo__get_url(self)

    def _get_schema_ver_major(self):
        r"""

        Returns the major version of the schema this URL refers to.

        :rtype: int

        """
        return _gentl.URLInfo__get_schema_ver_major(self)

    def _get_schema_ver_minor(self):
        r"""

        Returns the minor version of the schema this URL refers to.

        :rtype: int

        """
        return _gentl.URLInfo__get_schema_ver_minor(self)

    def _get_file_ver_major(self):
        r"""

        Returns the major version of the XML-file this URL refers to.

        :rtype: int

        """
        return _gentl.URLInfo__get_file_ver_major(self)

    def _get_file_ver_minor(self):
        r"""

        Returns the minor version of the XML-file this URL refers to.

        :rtype: int

        """
        return _gentl.URLInfo__get_file_ver_minor(self)

    def _get_file_ver_subminor(self):
        r"""

        Returns the sub-minor version of the XML-file this URL refers to.

        :rtype: int

        """
        return _gentl.URLInfo__get_file_ver_subminor(self)

    def get_file_sha1_hash(self, out_buffer):
        r"""

        Returns a :class:`bytes` object as a result of SHA1 Hash of the XML-file this URL refers to. The size of the provided buffer is 160Bit according to the SHA1 specification.

        :rtype: bytes

        """
        return _gentl.URLInfo_get_file_sha1_hash(self, out_buffer)

    def _get_file_register_address(self):
        r"""

        Returns the register address of the XML-File in the device's register map.

        :rtype: int

        """
        return _gentl.URLInfo__get_file_register_address(self)

    def _get_file_size(self):
        r"""

        Returns the file size of the XML-File in bytes.

        :rtype: int

        """
        return _gentl.URLInfo__get_file_size(self)

    def _get_scheme(self):
        r"""

        Returns the scheme of the URL.

        :rtype: int

        """
        return _gentl.URLInfo__get_scheme(self)

    def _get_file_name(self):
        r"""

        Returns the filename in case the scheme of the URL is :const:`~gentl.URL_SCHEME_IDS.URL_SCHEME_FILE` or as a hint if the scheme is :const:`~gentl.URL_SCHEME_IDS.URL_SCHEME_LOCAL`.

        :rtype: str

        """
        return _gentl.URLInfo__get_file_name(self)

    url = property(_get_url)


    schema_ver_major = property(_get_schema_ver_major)


    schema_ver_minor = property(_get_schema_ver_minor)


    file_ver_major = property(_get_file_ver_major)


    file_ver_minor = property(_get_file_ver_minor)


    file_ver_subminor = property(_get_file_ver_subminor)


    file_register_address = property(_get_file_register_address)


    file_size = property(_get_file_size)


    scheme = property(_get_scheme)


    file_name = property(_get_file_name)


    def get_info_int16(self, infoCmd):
        return _gentl.URLInfo_get_info_int16(self, infoCmd)

    def get_info_uint16(self, infoCmd):
        return _gentl.URLInfo_get_info_uint16(self, infoCmd)

    def get_info_int32(self, infoCmd):
        return _gentl.URLInfo_get_info_int32(self, infoCmd)

    def get_info_uint32(self, infoCmd):
        return _gentl.URLInfo_get_info_uint32(self, infoCmd)

    def get_info_int64(self, infoCmd):
        return _gentl.URLInfo_get_info_int64(self, infoCmd)

    def get_info_uint64(self, infoCmd):
        return _gentl.URLInfo_get_info_uint64(self, infoCmd)

    def get_info_float64(self, infoCmd):
        return _gentl.URLInfo_get_info_float64(self, infoCmd)

    def get_info_bool(self, infoCmd):
        return _gentl.URLInfo_get_info_bool(self, infoCmd)

    def get_info_sizet(self, infoCmd):
        return _gentl.URLInfo_get_info_sizet(self, infoCmd)

    def get_info_ptr(self, infoCmd):
        return _gentl.URLInfo_get_info_ptr(self, infoCmd)

    def get_info_string(self, infoCmd):
        return _gentl.URLInfo_get_info_string(self, infoCmd)

# Register URLInfo in _gentl:
_gentl.URLInfo_swigregister(URLInfo)

class DataStreamPort(Port):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, parent, handle):
        _gentl.DataStreamPort_swiginit(self, _gentl.new_DataStreamPort(parent, handle))
    __swig_destroy__ = _gentl.delete_DataStreamPort

    def _check_valid(self):
        r"""

        [OPEN]

        """
        return _gentl.DataStreamPort__check_valid(self)

    def _get_parent(self):
        return _gentl.DataStreamPort__get_parent(self)

    parent = property(_get_parent)


# Register DataStreamPort in _gentl:
_gentl.DataStreamPort_swigregister(DataStreamPort)

class DevicePort(Port):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, parent, handle):
        _gentl.DevicePort_swiginit(self, _gentl.new_DevicePort(parent, handle))
    __swig_destroy__ = _gentl.delete_DevicePort

    def _check_valid(self):
        r"""

        [OPEN]

        """
        return _gentl.DevicePort__check_valid(self)

    def _get_parent(self):
        return _gentl.DevicePort__get_parent(self)

    parent = property(_get_parent)


# Register DevicePort in _gentl:
_gentl.DevicePort_swigregister(DevicePort)

class InterfacePort(Port):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, parent, handle):
        _gentl.InterfacePort_swiginit(self, _gentl.new_InterfacePort(parent, handle))
    __swig_destroy__ = _gentl.delete_InterfacePort

    def _check_valid(self):
        r"""

        [OPEN]

        """
        return _gentl.InterfacePort__check_valid(self)

    def _get_parent(self):
        return _gentl.InterfacePort__get_parent(self)

    parent = property(_get_parent)


# Register InterfacePort in _gentl:
_gentl.InterfacePort_swigregister(InterfacePort)

class SystemPort(Port):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, parent, handle):
        _gentl.SystemPort_swiginit(self, _gentl.new_SystemPort(parent, handle))
    __swig_destroy__ = _gentl.delete_SystemPort

    def _check_valid(self):
        r"""

        [OPEN]

        """
        return _gentl.SystemPort__check_valid(self)

    def _get_parent(self):
        return _gentl.SystemPort__get_parent(self)

    parent = property(_get_parent)


# Register SystemPort in _gentl:
_gentl.SystemPort_swigregister(SystemPort)


def _start_redirection():
    return _gentl._start_redirection()

def _stop_redirection():
    return _gentl._stop_redirection()

def _trace(arg1):
    return _gentl._trace(arg1)

__version__ = '0.1.1'


class Helper():
    @staticmethod
    def is_running_on_macos():
        """
        Returns a truth value for a proposition: "the program is running on a
        macOS machine".

        :rtype: bool
        """
        pattern = re.compile('darwin', re.IGNORECASE)
        return False if not pattern.search(platform.platform()) else True


    @staticmethod
    def is_running_on_windows():
        """
        Returns a truth value for a proposition: "the program is running on a
        Windows machine".

        :rtype: bool
        """
        pattern = re.compile('windows', re.IGNORECASE)
        return False if not pattern.search(platform.platform()) else True


    @staticmethod
    def is_running_on_64_bit():
        """
        Returns a truth value for a proposition: "the program is running on a
        64-bit machine".

        :rtype: bool
        """
        return True if ctypes.sizeof(ctypes.c_voidp) == 8 else False


    @classmethod
    def get_cti_files(self):
        """
        Having a proper environment variable, either ``GENICAM_GENTL32_PATH`` or
        ``GENICAM_GENTL64_PATH``, returns the listed GenTL Producers.

        Returns:
            str: A list of listed GenTL Producers.

        """
        var_name = 'GENICAM_GENTL64_PATH' \
            if self.is_running_on_64_bit() else 'GENICAM_GENTL32_PATH'
        try:
            files = os.environ[var_name]
        except KeyError:
            files = []
        else:
            delimiter = ';' if self.is_running_on_windows() else ':'
            files = files.split(delimiter)
        return files

    @classmethod
    def format_path(self, path):
        """
        Formats the path specified by ``path`` and returns it.

        """

        if self.is_running_on_windows():
            path = path.replace('/', '\\')
        return path



