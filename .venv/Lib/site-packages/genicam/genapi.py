# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


import weakref
import ctypes
from sys import getrefcount


#
_incref = ctypes.pythonapi.Py_IncRef
_incref.argtypes = [ctypes.py_object]
_incref.restype = None


#
_decref = ctypes.pythonapi.Py_DecRef
_decref.argtypes = [ctypes.py_object]
_decref.restype = None




from enum import IntEnum


from warnings import warn


import weakref



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _genapi
else:
    import _genapi

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genapi.delete_SwigPyIterator

    def value(self):
        return _genapi.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _genapi.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _genapi.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _genapi.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _genapi.SwigPyIterator_equal(self, x)

    def copy(self):
        return _genapi.SwigPyIterator_copy(self)

    def next(self):
        return _genapi.SwigPyIterator_next(self)

    def __next__(self):
        return _genapi.SwigPyIterator___next__(self)

    def previous(self):
        return _genapi.SwigPyIterator_previous(self)

    def advance(self, n):
        return _genapi.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _genapi.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _genapi.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _genapi.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _genapi.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _genapi.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _genapi.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _genapi:
_genapi.SwigPyIterator_swigregister(SwigPyIterator)

class ios_base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _genapi.ios_base_erase_event
    imbue_event = _genapi.ios_base_imbue_event
    copyfmt_event = _genapi.ios_base_copyfmt_event

    def register_callback(self, __fn, __index):
        return _genapi.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args):
        return _genapi.ios_base_flags(self, *args)

    def setf(self, *args):
        return _genapi.ios_base_setf(self, *args)

    def unsetf(self, __mask):
        return _genapi.ios_base_unsetf(self, __mask)

    def precision(self, *args):
        return _genapi.ios_base_precision(self, *args)

    def width(self, *args):
        return _genapi.ios_base_width(self, *args)

    @staticmethod
    def sync_with_stdio(__sync=True):
        return _genapi.ios_base_sync_with_stdio(__sync)

    def imbue(self, __loc):
        return _genapi.ios_base_imbue(self, __loc)

    def getloc(self):
        return _genapi.ios_base_getloc(self)

    @staticmethod
    def xalloc():
        return _genapi.ios_base_xalloc()

    def iword(self, __ix):
        return _genapi.ios_base_iword(self, __ix)

    def pword(self, __ix):
        return _genapi.ios_base_pword(self, __ix)
    __swig_destroy__ = _genapi.delete_ios_base

# Register ios_base in _genapi:
_genapi.ios_base_swigregister(ios_base)
cvar = _genapi.cvar
ios_base.boolalpha = _genapi.cvar.ios_base_boolalpha
ios_base.dec = _genapi.cvar.ios_base_dec
ios_base.fixed = _genapi.cvar.ios_base_fixed
ios_base.hex = _genapi.cvar.ios_base_hex
ios_base.internal = _genapi.cvar.ios_base_internal
ios_base.left = _genapi.cvar.ios_base_left
ios_base.oct = _genapi.cvar.ios_base_oct
ios_base.right = _genapi.cvar.ios_base_right
ios_base.scientific = _genapi.cvar.ios_base_scientific
ios_base.showbase = _genapi.cvar.ios_base_showbase
ios_base.showpoint = _genapi.cvar.ios_base_showpoint
ios_base.showpos = _genapi.cvar.ios_base_showpos
ios_base.skipws = _genapi.cvar.ios_base_skipws
ios_base.unitbuf = _genapi.cvar.ios_base_unitbuf
ios_base.uppercase = _genapi.cvar.ios_base_uppercase
ios_base.adjustfield = _genapi.cvar.ios_base_adjustfield
ios_base.basefield = _genapi.cvar.ios_base_basefield
ios_base.floatfield = _genapi.cvar.ios_base_floatfield
ios_base.badbit = _genapi.cvar.ios_base_badbit
ios_base.eofbit = _genapi.cvar.ios_base_eofbit
ios_base.failbit = _genapi.cvar.ios_base_failbit
ios_base.goodbit = _genapi.cvar.ios_base_goodbit
ios_base.app = _genapi.cvar.ios_base_app
ios_base.ate = _genapi.cvar.ios_base_ate
ios_base.binary = _genapi.cvar.ios_base_binary
ios_base.ios_base_in = _genapi.cvar.ios_base_ios_base_in
ios_base.out = _genapi.cvar.ios_base_out
ios_base.trunc = _genapi.cvar.ios_base_trunc
ios_base.beg = _genapi.cvar.ios_base_beg
ios_base.cur = _genapi.cvar.ios_base_cur
ios_base.end = _genapi.cvar.ios_base_end

def ios_base_sync_with_stdio(__sync=True):
    return _genapi.ios_base_sync_with_stdio(__sync)

def ios_base_xalloc():
    return _genapi.ios_base_xalloc()

class ios(ios_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def rdstate(self):
        return _genapi.ios_rdstate(self)

    def clear(self, *args):
        return _genapi.ios_clear(self, *args)

    def setstate(self, __state):
        return _genapi.ios_setstate(self, __state)

    def good(self):
        return _genapi.ios_good(self)

    def eof(self):
        return _genapi.ios_eof(self)

    def fail(self):
        return _genapi.ios_fail(self)

    def bad(self):
        return _genapi.ios_bad(self)

    def exceptions(self, *args):
        return _genapi.ios_exceptions(self, *args)

    def __init__(self, __sb):
        _genapi.ios_swiginit(self, _genapi.new_ios(__sb))
    __swig_destroy__ = _genapi.delete_ios

    def tie(self, *args):
        return _genapi.ios_tie(self, *args)

    def rdbuf(self, *args):
        return _genapi.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs):
        return _genapi.ios_copyfmt(self, __rhs)

    def fill(self, *args):
        return _genapi.ios_fill(self, *args)

    def imbue(self, __loc):
        return _genapi.ios_imbue(self, __loc)

    def narrow(self, __c, __dfault):
        return _genapi.ios_narrow(self, __c, __dfault)

    def widen(self, __c):
        return _genapi.ios_widen(self, __c)

# Register ios in _genapi:
_genapi.ios_swigregister(ios)


GenericException = _genapi.GenericException


InvalidArgumentException = _genapi.InvalidArgumentException


OutOfRangeException = _genapi.OutOfRangeException


PropertyException = _genapi.PropertyException


RuntimeException = _genapi.RuntimeException


LogicalErrorException = _genapi.LogicalErrorException


AccessException = _genapi.AccessException


TimeoutException = _genapi.TimeoutException


DynamicCastException = _genapi.DynamicCastException


reference_implementation_version = '3.4.2'


class StackEntryItems(IntEnum):
    """
    Defines element IDs in StackEntryItems
    """
    Address     = 0
    Buffer      = 1
    ItemCount   = 2


class ESign(IntEnum):
    """
    signed or unsigned integers
    """
    Signed          = 0     #: Integer is signed
    Unsigned        = 1     #: Integer is unsigned
    _UndefinedSign  = 2     #: Object is not yet initialized


class EAccessMode(IntEnum):
    """
    access mode of a node
    """
    NI              = 0     #: Not implemented
    NA              = 1     #: Not available
    WO              = 2     #: Write Only
    RO              = 3     #: Read Only
    RW                    = 4       #: Read and Write
    _UndefinedAccesMode   = 5 #: Object is not yet initialized
    _CycleDetectAccesMode = 6   #: used internally for AccessMode cycle detection


class EVisibility(IntEnum):
    """
    recommended visibility of a node
    """
    Beginner = 0,              #: Always visible
    Expert = 1,                #: Visible for experts or Gurus
    Guru = 2,                  #: Visible for Gurus
    Invisible = 3,             #: Not Visible
    _UndefinedVisibility  = 99 #: Object is not yet initialized


class ECachingMode(IntEnum):
    """
    caching mode of a register
    """
    NoCache = 0              #: Do not use cache
    WriteThrough = 1         #: Write to cache and register
    WriteAround = 2          #: Write to register, write to cache on read
    _UndefinedCachingMode = 3#: Not yet initialized


class ERepresentation(IntEnum):
    """
    recommended representation of a node value
    """
    Linear = 0                     #: Slider with linear behavior
    Logarithmic = 1                #: Slider with logarithmic behaviour
    Boolean = 2                    #: Check box
    PureNumber = 3                 #: Decimal number in an edit control
    HexNumber = 4                  #: Hex number in an edit control
    IPV4Address = 5                #: IP-Address
    MACAddress = 6                 #: MAC-Address
    _UndefinedRepresentation = 7   #: undefined


class EEndianess(IntEnum):
    """
    Endianess of a value in a register
    """
    BigEndian = 0        #: Register is big endian
    LittleEndian = 1     #: Register is little endian
    _UndefinedEndian = 2 #: Object is not yet initialized


class ENameSpace(IntEnum):
    """
    Defines if a node name is standard or custom
    """
    Custom = 0              #: name resides in custom namespace
    Standard = 1           #: name resides in one of the standard namespaces
    _UndefinedNameSpace = 2#: Object is not yet initialized


class EStandardNameSpace(IntEnum):
    """
    Defines from which standard namespace a node name comes from
    """
    Custom = 0          #: name resides in custom namespace
    GEV = 1             #: name resides in GigE Vision namespace
    IIDC = 2            #: name resides in 1394 IIDC namespace
    CL = 3              #: name resides in camera link namespace
    USB = 4             #: name resides in USB namespace
    _UndefinedStandardNameSpace = 5  #: Object is not yet initialized


class EYesNo(IntEnum):
    """
    Defines the chices of a Yes/No alternaitve
    """
    No = 0,                 #: no
    Yes = 1,                #: yes
    _UndefinedYesNo = 2     #: Object is not yet initialized


class ESlope(IntEnum):
    """
    typedef for fomula type
    """
    Increasing = 0      #: strictly monotonous increasing
    Decreasing = 1      #: strictly monotonous decreasing
    Varying = 2         #: slope changes, e.g. at run-time
    Automatic = 3      #: slope is determined automatically by probing the function
    _UndefinedESlope  = 4#: Object is not yet initialized


class EXMLValidation(IntEnum):
    """
    typedef describing the different validity checks which can be performed on an XML file
    """
    xvLoad      = 0x00000001    #: Creates a dummy node map
    xvCycles    = 0x00000002    #: checks for write and dependency cycles (implies xvLoad)
    xvSFNC      = 0x00000004    #: checks for conformance with the standard feature naming convention (SFNC)
    xvDefault   = 0x00000000    #: checks performed if nothing else is said
    xvAll       = 0xffffffff    #: all possible checks
    _UndefinedEXMLValidation = 0x8000000 #: Object is not yet initialized


class EDisplayNotation(IntEnum):
    """
    typedef for float notation
    """
    fnAutomatic = 0                #: the notation if either scientific or fixed depending on what is shorter
    fnFixed = 1                    #: the notation is fixed, e.g. 123.4
    fnScientific = 2               #: the notation is scientific, e.g. 1.234e2
    _UndefinedEDisplayNotation = 3 #: Object is not yet initialized


class EInterfaceType(IntEnum):
    """
    typedef for interface type
    """
    intfIValue = 0       #: IValue interface
    intfIBase = 1        #: IBase interface
    intfIInteger = 2     #: IInteger interface
    intfIBoolean = 3     #: IBoolean interface
    intfICommand = 4     #: ICommand interface
    intfIFloat = 5       #: IFloat interface
    intfIString = 6      #: IString interface
    intfIRegister = 7    #: IRegister interface
    intfICategory = 8    #: ICategory interface
    intfIEnumeration = 9 #: IEnumeration interface
    intfIEnumEntry = 10   #: IEnumEntry interface
    intfIPort       = 11  #: IPort interface


class ELinkType(IntEnum):
    """
    typedef for link type For details see GenICam wiki : GenApi/SoftwareArchitecture/NodeDependencies
    """
    ctParentNodes = 0                       #: All nodes for which this node is at least an invalidating child
    ctReadingChildren = 1           #: All nodes which can be read from
    ctWritingChildren = 2           #: All nodes which can write a value further down the node stack
    ctInvalidatingChildren = 3 #: All directly connected nodes which invalidate this node
    ctDependingNodes = 4    #: All directly or indirectly connected nodes which are invalidated by this nodes (i.e. which are dependent on this node)
    ctTerminalNodes = 5         #: All indirectly connected terminal nodes


class EIncMode(IntEnum):
    """
    typedef for increment mode
    """
    noIncrement = 0    #: The feature has no increment
    fixedIncrement = 1 #: The feature has a fix increment
    listIncrement = 2  #: The feature has a list of valid value


class EInputDirection(IntEnum):
    """
    typedef for link type
    """
    idFrom = 0 #: Indicates a swiss knife that it is used as worker for a converter computing FROM
    idTo = 1   #: Indicates a swiss knife that it is used as worker for a converter computing TO
    idNone = 2 #: SwissKnife is not used within a converter


class ECallbackType(IntEnum):
    """
    the type of callback
    """
    cbPostInsideLock = 1   #: callback is fired on leaving the tree inside the lock-guarded area
    cbPostOutsideLock = 2  #: callback is fired on leaving the tree inside the lock-guarded area

class CNodeWriteConcatenator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def add(self, *args):
        return _genapi.CNodeWriteConcatenator_add(self, *args)

    def clear(self):
        return _genapi.CNodeWriteConcatenator_clear(self)

    def destroy(self):
        return _genapi.CNodeWriteConcatenator_destroy(self)

# Register CNodeWriteConcatenator in _genapi:
_genapi.CNodeWriteConcatenator_swigregister(CNodeWriteConcatenator)

class _NodeWriteConcatenator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _genapi._NodeWriteConcatenator_swiginit(self, _genapi.new__NodeWriteConcatenator(*args))
    __swig_destroy__ = _genapi.delete__NodeWriteConcatenator

    def add(self, *args):
        return _genapi._NodeWriteConcatenator_add(self, *args)

    def clear(self):
        return _genapi._NodeWriteConcatenator_clear(self)

# Register _NodeWriteConcatenator in _genapi:
_genapi._NodeWriteConcatenator_swigregister(_NodeWriteConcatenator)

class ESignClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.ESignClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.ESignClass_to_string(*args)

    def __init__(self):
        _genapi.ESignClass_swiginit(self, _genapi.new_ESignClass())
    __swig_destroy__ = _genapi.delete_ESignClass

# Register ESignClass in _genapi:
_genapi.ESignClass_swigregister(ESignClass)

def ESignClass_from_string(ValueStr, pValue):
    return _genapi.ESignClass_from_string(ValueStr, pValue)

def ESignClass_to_string(*args):
    return _genapi.ESignClass_to_string(*args)

class EEndianessClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.EEndianessClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.EEndianessClass_to_string(*args)

    def __init__(self):
        _genapi.EEndianessClass_swiginit(self, _genapi.new_EEndianessClass())
    __swig_destroy__ = _genapi.delete_EEndianessClass

# Register EEndianessClass in _genapi:
_genapi.EEndianessClass_swigregister(EEndianessClass)

def EEndianessClass_from_string(ValueStr, pValue):
    return _genapi.EEndianessClass_from_string(ValueStr, pValue)

def EEndianessClass_to_string(*args):
    return _genapi.EEndianessClass_to_string(*args)

class ERepresentationClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.ERepresentationClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.ERepresentationClass_to_string(*args)

    def __init__(self):
        _genapi.ERepresentationClass_swiginit(self, _genapi.new_ERepresentationClass())
    __swig_destroy__ = _genapi.delete_ERepresentationClass

# Register ERepresentationClass in _genapi:
_genapi.ERepresentationClass_swigregister(ERepresentationClass)

def ERepresentationClass_from_string(ValueStr, pValue):
    return _genapi.ERepresentationClass_from_string(ValueStr, pValue)

def ERepresentationClass_to_string(*args):
    return _genapi.ERepresentationClass_to_string(*args)

class EVisibilityClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.EVisibilityClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.EVisibilityClass_to_string(*args)

    def __init__(self):
        _genapi.EVisibilityClass_swiginit(self, _genapi.new_EVisibilityClass())
    __swig_destroy__ = _genapi.delete_EVisibilityClass

# Register EVisibilityClass in _genapi:
_genapi.EVisibilityClass_swigregister(EVisibilityClass)

def EVisibilityClass_from_string(ValueStr, pValue):
    return _genapi.EVisibilityClass_from_string(ValueStr, pValue)

def EVisibilityClass_to_string(*args):
    return _genapi.EVisibilityClass_to_string(*args)

class EAccessModeClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.EAccessModeClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.EAccessModeClass_to_string(*args)

    def __init__(self):
        _genapi.EAccessModeClass_swiginit(self, _genapi.new_EAccessModeClass())
    __swig_destroy__ = _genapi.delete_EAccessModeClass

# Register EAccessModeClass in _genapi:
_genapi.EAccessModeClass_swigregister(EAccessModeClass)

def EAccessModeClass_from_string(ValueStr, pValue):
    return _genapi.EAccessModeClass_from_string(ValueStr, pValue)

def EAccessModeClass_to_string(*args):
    return _genapi.EAccessModeClass_to_string(*args)

class ECachingModeClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.ECachingModeClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.ECachingModeClass_to_string(*args)

    def __init__(self):
        _genapi.ECachingModeClass_swiginit(self, _genapi.new_ECachingModeClass())
    __swig_destroy__ = _genapi.delete_ECachingModeClass

# Register ECachingModeClass in _genapi:
_genapi.ECachingModeClass_swigregister(ECachingModeClass)

def ECachingModeClass_from_string(ValueStr, pValue):
    return _genapi.ECachingModeClass_from_string(ValueStr, pValue)

def ECachingModeClass_to_string(*args):
    return _genapi.ECachingModeClass_to_string(*args)

class ENameSpaceClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.ENameSpaceClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.ENameSpaceClass_to_string(*args)

    def __init__(self):
        _genapi.ENameSpaceClass_swiginit(self, _genapi.new_ENameSpaceClass())
    __swig_destroy__ = _genapi.delete_ENameSpaceClass

# Register ENameSpaceClass in _genapi:
_genapi.ENameSpaceClass_swigregister(ENameSpaceClass)

def ENameSpaceClass_from_string(ValueStr, pValue):
    return _genapi.ENameSpaceClass_from_string(ValueStr, pValue)

def ENameSpaceClass_to_string(*args):
    return _genapi.ENameSpaceClass_to_string(*args)

class EYesNoClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.EYesNoClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.EYesNoClass_to_string(*args)

    def __init__(self):
        _genapi.EYesNoClass_swiginit(self, _genapi.new_EYesNoClass())
    __swig_destroy__ = _genapi.delete_EYesNoClass

# Register EYesNoClass in _genapi:
_genapi.EYesNoClass_swigregister(EYesNoClass)

def EYesNoClass_from_string(ValueStr, pValue):
    return _genapi.EYesNoClass_from_string(ValueStr, pValue)

def EYesNoClass_to_string(*args):
    return _genapi.EYesNoClass_to_string(*args)

class EStandardNameSpaceClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.EStandardNameSpaceClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.EStandardNameSpaceClass_to_string(*args)

    def __init__(self):
        _genapi.EStandardNameSpaceClass_swiginit(self, _genapi.new_EStandardNameSpaceClass())
    __swig_destroy__ = _genapi.delete_EStandardNameSpaceClass

# Register EStandardNameSpaceClass in _genapi:
_genapi.EStandardNameSpaceClass_swigregister(EStandardNameSpaceClass)

def EStandardNameSpaceClass_from_string(ValueStr, pValue):
    return _genapi.EStandardNameSpaceClass_from_string(ValueStr, pValue)

def EStandardNameSpaceClass_to_string(*args):
    return _genapi.EStandardNameSpaceClass_to_string(*args)

class ESlopeClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.ESlopeClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.ESlopeClass_to_string(*args)

    def __init__(self):
        _genapi.ESlopeClass_swiginit(self, _genapi.new_ESlopeClass())
    __swig_destroy__ = _genapi.delete_ESlopeClass

# Register ESlopeClass in _genapi:
_genapi.ESlopeClass_swigregister(ESlopeClass)

def ESlopeClass_from_string(ValueStr, pValue):
    return _genapi.ESlopeClass_from_string(ValueStr, pValue)

def ESlopeClass_to_string(*args):
    return _genapi.ESlopeClass_to_string(*args)

class EDisplayNotationClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.EDisplayNotationClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.EDisplayNotationClass_to_string(*args)

    def __init__(self):
        _genapi.EDisplayNotationClass_swiginit(self, _genapi.new_EDisplayNotationClass())
    __swig_destroy__ = _genapi.delete_EDisplayNotationClass

# Register EDisplayNotationClass in _genapi:
_genapi.EDisplayNotationClass_swigregister(EDisplayNotationClass)

def EDisplayNotationClass_from_string(ValueStr, pValue):
    return _genapi.EDisplayNotationClass_from_string(ValueStr, pValue)

def EDisplayNotationClass_to_string(*args):
    return _genapi.EDisplayNotationClass_to_string(*args)

class EInputDirectionClass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def from_string(ValueStr, pValue):
        return _genapi.EInputDirectionClass_from_string(ValueStr, pValue)

    @staticmethod
    def to_string(*args):
        return _genapi.EInputDirectionClass_to_string(*args)

    def __init__(self):
        _genapi.EInputDirectionClass_swiginit(self, _genapi.new_EInputDirectionClass())
    __swig_destroy__ = _genapi.delete_EInputDirectionClass

# Register EInputDirectionClass in _genapi:
_genapi.EInputDirectionClass_swigregister(EInputDirectionClass)

def EInputDirectionClass_from_string(ValueStr, pValue):
    return _genapi.EInputDirectionClass_from_string(ValueStr, pValue)

def EInputDirectionClass_to_string(*args):
    return _genapi.EInputDirectionClass_to_string(*args)

class Version(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Major = property(_genapi.Version_Major_get, _genapi.Version_Major_set)
    Minor = property(_genapi.Version_Minor_get, _genapi.Version_Minor_set)
    SubMinor = property(_genapi.Version_SubMinor_get, _genapi.Version_SubMinor_set)

    def __init__(self):
        _genapi.Version_swiginit(self, _genapi.new_Version())
    __swig_destroy__ = _genapi.delete_Version

# Register Version in _genapi:
_genapi.Version_swigregister(Version)

class IBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_access_mode(self):
        return _genapi.IBase_get_access_mode(self)

# Register IBase in _genapi:
_genapi.IBase_swigregister(IBase)

class INode(IBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primary_get_name(self, FullQualified=False):
        return _genapi.INode__primary_get_name(self, FullQualified)

    def _get_name_space(self):
        return _genapi.INode__get_name_space(self)

    def _get_visibility(self):
        return _genapi.INode__get_visibility(self)

    def invalidate_node(self):
        return _genapi.INode_invalidate_node(self)

    def is_cachable(self):
        return _genapi.INode_is_cachable(self)

    def is_access_mode_cacheable(self):
        return _genapi.INode_is_access_mode_cacheable(self)

    def _get_caching_mode(self):
        return _genapi.INode__get_caching_mode(self)

    def _get_polling_time(self):
        return _genapi.INode__get_polling_time(self)

    def _get_tooltip(self):
        return _genapi.INode__get_tooltip(self)

    def _get_description(self):
        return _genapi.INode__get_description(self)

    def _get_display_name(self):
        return _genapi.INode__get_display_name(self)

    def _get_device_name(self):
        return _genapi.INode__get_device_name(self)

    def _get_children(self, *args):
        return _genapi.INode__get_children(self, *args)

    def _get_parents(self):
        return _genapi.INode__get_parents(self)

    def register_callback(self, INPUT):
        return _genapi.INode_register_callback(self, INPUT)

    def deregister_callback(self, hCallback):
        return _genapi.INode_deregister_callback(self, hCallback)

    def _get_node_map(self):
        return _genapi.INode__get_node_map(self)

    def _get_event_id(self):
        return _genapi.INode__get_event_id(self)

    def is_streamable(self):
        return _genapi.INode_is_streamable(self)

    def _get_property_names(self):
        return _genapi.INode__get_property_names(self)

    def get_property(self, PropertyName):
        return _genapi.INode_get_property(self, PropertyName)

    def impose_access_mode(self, ImposedAccessMode):
        return _genapi.INode_impose_access_mode(self, ImposedAccessMode)

    def impose_visibility(self, ImposedVisibility):
        return _genapi.INode_impose_visibility(self, ImposedVisibility)

    def _get_alias(self):
        return _genapi.INode__get_alias(self)

    def _get_cast_alias(self):
        return _genapi.INode__get_cast_alias(self)

    def _get_docu_url(self):
        return _genapi.INode__get_docu_url(self)

    def is_deprecated(self):
        return _genapi.INode_is_deprecated(self)

    def _get_principal_interface_type(self):
        return _genapi.INode__get_principal_interface_type(self)

    def is_feature(self):
        return _genapi.INode_is_feature(self)

    def is_selector(self):
        return _genapi.INode_is_selector(self)

    def _get_selected_features(self):
        return _genapi.INode__get_selected_features(self)

    def _get_selecting_features(self):
        return _genapi.INode__get_selecting_features(self)

    name_space = property(_get_name_space)


    visibility = property(_get_visibility)


    caching_mode = property(_get_caching_mode)


    polling_time = property(_get_polling_time)


    tooltip = property(_get_tooltip)


    description = property(_get_description)


    display_name = property(_get_display_name)


    device_name = property(_get_device_name)


    children = property(_get_children)


    parents = property(_get_parents)


    node_map = property(_get_node_map)


    event_id = property(_get_event_id)


    property_names = property(_get_property_names)


    alias = property(_get_alias)


    cast_alias = property(_get_cast_alias)


    docu_url = property(_get_docu_url)


    principal_interface_type = property(_get_principal_interface_type)


    def _get_name(self):
        return self._primary_get_name()

    def _get_name_full_qualified(self):
        return self._primary_get_name(True)



    name = property(_get_name)


    name_full_qualified = property(_get_name_full_qualified)


    selected_features = property(_get_selected_features)


    selecting_features = property(_get_selecting_features)


# Register INode in _genapi:
_genapi.INode_swigregister(INode)


def is_readable(*args):
    return _genapi.is_readable(*args)

def is_writable(*args):
    return _genapi.is_writable(*args)

def is_implemented(*args):
    return _genapi.is_implemented(*args)

def is_available(*args):
    return _genapi.is_available(*args)

def combine(Peter, Paul):
    return _genapi.combine(Peter, Paul)

def is_visible(Visibility, MaxVisiblity):
    return _genapi.is_visible(Visibility, MaxVisiblity)

def CombineVisibility(Peter, Paul):
    return _genapi.CombineVisibility(Peter, Paul)

def is_cacheable(CachingMode):
    return _genapi.is_cacheable(CachingMode)

def CombineCachingMode(Peter, Paul):
    return _genapi.CombineCachingMode(Peter, Paul)
class INodeMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_nodes(self):
        return _genapi.INodeMap__get_nodes(self)

    def get_node(self, Name):
        return _genapi.INodeMap_get_node(self, Name)

    def invalidate_nodes(self):
        return _genapi.INodeMap_invalidate_nodes(self)

    def connect(self, *args):
        return _genapi.INodeMap_connect(self, *args)

    def _get_device_name(self):
        return _genapi.INodeMap__get_device_name(self)

    def poll(self, ElapsedTime):
        return _genapi.INodeMap_poll(self, ElapsedTime)

    def _get_lock(self):
        return _genapi.INodeMap__get_lock(self)

    def _get_num_nodes(self):
        return _genapi.INodeMap__get_num_nodes(self)

    def _get_device_info(self):
        return _genapi.INodeMap__get_device_info(self)

    device_name = property(_get_device_name)


    device_info = property(_get_device_info)


    nodes = property(_get_nodes)


    lock = property(_get_lock)


    num_nodes = property(_get_num_nodes)


    def __getattr__(self, attribute):
        if attribute in self.__dict__ or attribute in ("thisown", "this"):
            return object.__getattr__(self, attribute)
        else:
            return self.get_node(attribute)

    def __setattr__(self, attribute, val):
        if attribute in self.__dict__ or attribute in ("thisown", "this"):
            object.__setattr__(self, attribute, val)
        else:
            self.get_node(attribute).set_value(val)

    def __dir__(self):
        l = []
        l += [x for x in dir(type(self))]
        l += [x for x in self.__dict__.keys()]
        try:
            l += [x.node.name for x in filter(lambda n: n.node.is_feature(), self.nodes)]
        except:
            pass
        try:
            l += [x.node for x in filter(lambda n: "ChunkData" in (f.node.name for f in n.node.parents), self.nodes)]
        except:
            pass
        return sorted(set(l))


# Register INodeMap in _genapi:
_genapi.INodeMap_swigregister(INodeMap)


def deregister(pCallbackInfo):
    return _genapi.deregister(pCallbackInfo)
class PyNodeCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNode, PyFunc, CallbackType):
        _genapi.PyNodeCallback_swiginit(self, _genapi.new_PyNodeCallback(pNode, PyFunc, CallbackType))
    __swig_destroy__ = _genapi.delete_PyNodeCallback

    def _get_node(self):
        return _genapi.PyNodeCallback__get_node(self)

    node = property(_get_node)


# Register PyNodeCallback in _genapi:
_genapi.PyNodeCallback_swigregister(PyNodeCallback)


def register(node, callback_fun, callback_type=ECallbackType.cbPostInsideLock):
    assert callback_type in ( ECallbackType.cbPostOutsideLock, ECallbackType.cbPostInsideLock)
    cb = PyNodeCallback(node, callback_fun, callback_type)
    cb.thisown = 0
    return node.register_callback(cb)


class IValue(IBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_node(self):
        return _genapi.IValue__get_node(self)

    def to_string(self, Verify=False, IgnoreCache=False):
        return _genapi.IValue_to_string(self, Verify, IgnoreCache)

    def from_string(self, ValueStr, Verify=True):
        return _genapi.IValue_from_string(self, ValueStr, Verify)

    def is_value_cache_valid(self):
        return _genapi.IValue_is_value_cache_valid(self)

    node = property(_get_node)


# Register IValue in _genapi:
_genapi.IValue_swigregister(IValue)

class node_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _genapi.node_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _genapi.node_vector___nonzero__(self)

    def __bool__(self):
        return _genapi.node_vector___bool__(self)

    def __len__(self):
        return _genapi.node_vector___len__(self)

    def __getslice__(self, i, j):
        return _genapi.node_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _genapi.node_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _genapi.node_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _genapi.node_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _genapi.node_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _genapi.node_vector___setitem__(self, *args)

    def pop(self):
        return _genapi.node_vector_pop(self)

    def append(self, x):
        return _genapi.node_vector_append(self, x)

    def empty(self):
        return _genapi.node_vector_empty(self)

    def size(self):
        return _genapi.node_vector_size(self)

    def swap(self, v):
        return _genapi.node_vector_swap(self, v)

    def begin(self):
        return _genapi.node_vector_begin(self)

    def end(self):
        return _genapi.node_vector_end(self)

    def rbegin(self):
        return _genapi.node_vector_rbegin(self)

    def rend(self):
        return _genapi.node_vector_rend(self)

    def clear(self):
        return _genapi.node_vector_clear(self)

    def get_allocator(self):
        return _genapi.node_vector_get_allocator(self)

    def pop_back(self):
        return _genapi.node_vector_pop_back(self)

    def erase(self, *args):
        return _genapi.node_vector_erase(self, *args)

    def __init__(self, *args):
        _genapi.node_vector_swiginit(self, _genapi.new_node_vector(*args))

    def push_back(self, x):
        return _genapi.node_vector_push_back(self, x)

    def front(self):
        return _genapi.node_vector_front(self)

    def back(self):
        return _genapi.node_vector_back(self)

    def assign(self, n, x):
        return _genapi.node_vector_assign(self, n, x)

    def resize(self, *args):
        return _genapi.node_vector_resize(self, *args)

    def insert(self, *args):
        return _genapi.node_vector_insert(self, *args)

    def reserve(self, n):
        return _genapi.node_vector_reserve(self, n)

    def capacity(self):
        return _genapi.node_vector_capacity(self)
    __swig_destroy__ = _genapi.delete_node_vector

# Register node_vector in _genapi:
_genapi.node_vector_swigregister(node_vector)

class value_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _genapi.value_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _genapi.value_vector___nonzero__(self)

    def __bool__(self):
        return _genapi.value_vector___bool__(self)

    def __len__(self):
        return _genapi.value_vector___len__(self)

    def __getslice__(self, i, j):
        return _genapi.value_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _genapi.value_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _genapi.value_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _genapi.value_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _genapi.value_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _genapi.value_vector___setitem__(self, *args)

    def pop(self):
        return _genapi.value_vector_pop(self)

    def append(self, x):
        return _genapi.value_vector_append(self, x)

    def empty(self):
        return _genapi.value_vector_empty(self)

    def size(self):
        return _genapi.value_vector_size(self)

    def swap(self, v):
        return _genapi.value_vector_swap(self, v)

    def begin(self):
        return _genapi.value_vector_begin(self)

    def end(self):
        return _genapi.value_vector_end(self)

    def rbegin(self):
        return _genapi.value_vector_rbegin(self)

    def rend(self):
        return _genapi.value_vector_rend(self)

    def clear(self):
        return _genapi.value_vector_clear(self)

    def get_allocator(self):
        return _genapi.value_vector_get_allocator(self)

    def pop_back(self):
        return _genapi.value_vector_pop_back(self)

    def erase(self, *args):
        return _genapi.value_vector_erase(self, *args)

    def __init__(self, *args):
        _genapi.value_vector_swiginit(self, _genapi.new_value_vector(*args))

    def push_back(self, x):
        return _genapi.value_vector_push_back(self, x)

    def front(self):
        return _genapi.value_vector_front(self)

    def back(self):
        return _genapi.value_vector_back(self)

    def assign(self, n, x):
        return _genapi.value_vector_assign(self, n, x)

    def resize(self, *args):
        return _genapi.value_vector_resize(self, *args)

    def insert(self, *args):
        return _genapi.value_vector_insert(self, *args)

    def reserve(self, n):
        return _genapi.value_vector_reserve(self, n)

    def capacity(self):
        return _genapi.value_vector_capacity(self)
    __swig_destroy__ = _genapi.delete_value_vector

# Register value_vector in _genapi:
_genapi.value_vector_swigregister(value_vector)

class string_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _genapi.string_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _genapi.string_vector___nonzero__(self)

    def __bool__(self):
        return _genapi.string_vector___bool__(self)

    def __len__(self):
        return _genapi.string_vector___len__(self)

    def __getslice__(self, i, j):
        return _genapi.string_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _genapi.string_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _genapi.string_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _genapi.string_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _genapi.string_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _genapi.string_vector___setitem__(self, *args)

    def pop(self):
        return _genapi.string_vector_pop(self)

    def append(self, x):
        return _genapi.string_vector_append(self, x)

    def empty(self):
        return _genapi.string_vector_empty(self)

    def size(self):
        return _genapi.string_vector_size(self)

    def swap(self, v):
        return _genapi.string_vector_swap(self, v)

    def begin(self):
        return _genapi.string_vector_begin(self)

    def end(self):
        return _genapi.string_vector_end(self)

    def rbegin(self):
        return _genapi.string_vector_rbegin(self)

    def rend(self):
        return _genapi.string_vector_rend(self)

    def clear(self):
        return _genapi.string_vector_clear(self)

    def get_allocator(self):
        return _genapi.string_vector_get_allocator(self)

    def pop_back(self):
        return _genapi.string_vector_pop_back(self)

    def erase(self, *args):
        return _genapi.string_vector_erase(self, *args)

    def __init__(self, *args):
        _genapi.string_vector_swiginit(self, _genapi.new_string_vector(*args))

    def push_back(self, x):
        return _genapi.string_vector_push_back(self, x)

    def front(self):
        return _genapi.string_vector_front(self)

    def back(self):
        return _genapi.string_vector_back(self)

    def assign(self, n, x):
        return _genapi.string_vector_assign(self, n, x)

    def resize(self, *args):
        return _genapi.string_vector_resize(self, *args)

    def insert(self, *args):
        return _genapi.string_vector_insert(self, *args)

    def reserve(self, n):
        return _genapi.string_vector_reserve(self, n)

    def capacity(self):
        return _genapi.string_vector_capacity(self)
    __swig_destroy__ = _genapi.delete_string_vector

# Register string_vector in _genapi:
_genapi.string_vector_swigregister(string_vector)

class IPort(IBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def read(self, address, buffer):
        return _genapi.IPort_read(self, address, buffer)

    def write(self, address, buffer):
        return _genapi.IPort_write(self, address, buffer)

    def _get_node(self):
        return _genapi.IPort__get_node(self)

    def _get_chunk_id(self):
        return _genapi.IPort__get_chunk_id(self)

    def cache_chunk_data(self):
        return _genapi.IPort_cache_chunk_data(self)

    def _get_swap_endianess(self):
        return _genapi.IPort__get_swap_endianess(self)

    node = property(_get_node)


    chunk_id = property(_get_chunk_id)


    swap_endianess = property(_get_swap_endianess)


# Register IPort in _genapi:
_genapi.IPort_swigregister(IPort)

CHUNK_BASE_ADDRESS_REGISTER_LEN = _genapi.CHUNK_BASE_ADDRESS_REGISTER_LEN
CHUNK_LENGTH_REGISTER_LEN = _genapi.CHUNK_LENGTH_REGISTER_LEN
class IChunkPort(IPort):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_chunk_id(self):
        return _genapi.IChunkPort__get_chunk_id(self)

    def cache_chunk_data(self):
        return _genapi.IChunkPort_cache_chunk_data(self)

    chunk_id = property(_get_chunk_id)


# Register IChunkPort in _genapi:
_genapi.IChunkPort_swigregister(IChunkPort)

class IPortConstruct(IPort):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_swap_endianess(self):
        return _genapi.IPortConstruct__get_swap_endianess(self)

# Register IPortConstruct in _genapi:
_genapi.IPortConstruct_swigregister(IPortConstruct)

class IPortStackedConstruct(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genapi.delete_IPortStackedConstruct

# Register IPortStackedConstruct in _genapi:
_genapi.IPortStackedConstruct_swigregister(IPortStackedConstruct)

class IPortWriteList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def write(self, buffer, address, Length):
        return _genapi.IPortWriteList_write(self, buffer, address, Length)

    def replay(self, pPort):
        return _genapi.IPortWriteList_replay(self, pPort)

    def set_cookie(self, Value):
        return _genapi.IPortWriteList_set_cookie(self, Value)

    def _get_cookie(self):
        return _genapi.IPortWriteList__get_cookie(self)

    cookie = property(_get_cookie)


# Register IPortWriteList in _genapi:
_genapi.IPortWriteList_swigregister(IPortWriteList)

class IPortReplay(IPort):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def replay(self, pPortRecorder, Invalidate=True):
        return _genapi.IPortReplay_replay(self, pPortRecorder, Invalidate)

# Register IPortReplay in _genapi:
_genapi.IPortReplay_swigregister(IPortReplay)

class IPortRecorder(IPortReplay):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def start_recording(self, pPortRecorder):
        return _genapi.IPortRecorder_start_recording(self, pPortRecorder)

    def stop_recording(self):
        return _genapi.IPortRecorder_stop_recording(self)

# Register IPortRecorder in _genapi:
_genapi.IPortRecorder_swigregister(IPortRecorder)

class AbstractPort(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == AbstractPort:
            _self = None
        else:
            _self = self
        _genapi.AbstractPort_swiginit(self, _genapi.new_AbstractPort(_self, ))
    __swig_destroy__ = _genapi.delete_AbstractPort

    def get_access_mode(self):
        return _genapi.AbstractPort_get_access_mode(self)

    def read(self, address, buffer):
        return _genapi.AbstractPort_read(self, address, buffer)

    def write(self, address, buffer):
        return _genapi.AbstractPort_write(self, address, buffer)

    def invalidate_node(self):
        return _genapi.AbstractPort_invalidate_node(self)
    def __disown__(self):
        self.this.disown()
        _genapi.disown_AbstractPort(self)
        return weakref.proxy(self)

# Register AbstractPort in _genapi:
_genapi.AbstractPort_swigregister(AbstractPort)

class IPortStacked(IPort):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genapi.delete_IPortStacked

# Register IPortStacked in _genapi:
_genapi.IPortStacked_swigregister(IPortStacked)

class AbstractPortStacked(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == AbstractPortStacked:
            _self = None
        else:
            _self = self
        _genapi.AbstractPortStacked_swiginit(self, _genapi.new_AbstractPortStacked(_self, ))
    __swig_destroy__ = _genapi.delete_AbstractPortStacked

    def get_access_mode(self):
        return _genapi.AbstractPortStacked_get_access_mode(self)

    def read(self, address, buffer):
        return _genapi.AbstractPortStacked_read(self, address, buffer)

    def write(self, address, buffer):
        return _genapi.AbstractPortStacked_write(self, address, buffer)

    def stacked_write(self, entries):
        return _genapi.AbstractPortStacked_stacked_write(self, entries)

    def invalidate_node(self):
        return _genapi.AbstractPortStacked_invalidate_node(self)
    def __disown__(self):
        self.this.disown()
        _genapi.disown_AbstractPortStacked(self)
        return weakref.proxy(self)

# Register AbstractPortStacked in _genapi:
_genapi.AbstractPortStacked_swigregister(AbstractPortStacked)

class IDeviceInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_model_name(self):
        return _genapi.IDeviceInfo__get_model_name(self)

    def _get_vendor_name(self):
        return _genapi.IDeviceInfo__get_vendor_name(self)

    def _get_tooltip(self):
        return _genapi.IDeviceInfo__get_tooltip(self)

    def _get_standard_name_space(self):
        return _genapi.IDeviceInfo__get_standard_name_space(self)

    def _get_genapi_version(self):
        return _genapi.IDeviceInfo__get_genapi_version(self)

    def get_schema_version(self):
        return _genapi.IDeviceInfo_get_schema_version(self)

    def get_device_version(self):
        return _genapi.IDeviceInfo_get_device_version(self)

    def _get_product_guid(self):
        return _genapi.IDeviceInfo__get_product_guid(self)

    def _get_version_guid(self):
        return _genapi.IDeviceInfo__get_version_guid(self)

    genapi_version = property(_get_genapi_version)


    model_name = property(_get_model_name)


    vendor_name = property(_get_vendor_name)


    tooltip = property(_get_tooltip)


    standard_name_space = property(_get_standard_name_space)


    product_guid = property(_get_product_guid)


    version_guid = property(_get_version_guid)


# Register IDeviceInfo in _genapi:
_genapi.IDeviceInfo_swigregister(IDeviceInfo)

class NodeMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _genapi.NodeMap_swiginit(self, _genapi.new_NodeMap(*args))
    __swig_destroy__ = _genapi.delete_NodeMap

    def load_xml_from_file(self, FileName):
        return _genapi.NodeMap_load_xml_from_file(self, FileName)

    def load_xml_from_string(self, XMLData):
        return _genapi.NodeMap_load_xml_from_string(self, XMLData)

    def load_xml_from_zip_file(self, ZipFileName):
        return _genapi.NodeMap_load_xml_from_zip_file(self, ZipFileName)

    def _get_device_name(self):
        return _genapi.NodeMap__get_device_name(self)

    def poll(self, ElapsedTime):
        return _genapi.NodeMap_poll(self, ElapsedTime)

    def _destroy(self):
        return _genapi.NodeMap__destroy(self)

    @staticmethod
    def clear_xml_cache():
        return _genapi.NodeMap_clear_xml_cache()

    def _get_nodes(self):
        return _genapi.NodeMap__get_nodes(self)

    def _get_node(self, key):
        return _genapi.NodeMap__get_node(self, key)

    def get_node(self, key):
        return _genapi.NodeMap_get_node(self, key)

    def _create_new_write_concatenator(self):
        return _genapi.NodeMap__create_new_write_concatenator(self)

    def _invalidate_nodes(self):
        return _genapi.NodeMap__invalidate_nodes(self)

    def _connect(self, *args):
        return _genapi.NodeMap__connect(self, *args)

    def _cpp__parse_swiss_knives(self):
        return _genapi.NodeMap__cpp__parse_swiss_knives(self)
    pointer = property(_genapi.NodeMap_pointer_get, _genapi.NodeMap_pointer_set)

    def _get_device_info(self):
        return _genapi.NodeMap__get_device_info(self)

    device_info = property(_get_device_info)


    def parse_swiss_knives(self):
        is_valid, messages = self._cpp__parse_swiss_knives()
        return ValidationResult(is_valid=is_valid, messages=messages)


    def _cpp__concatenated_write(self, concatenator, feature_streaming):
        return _genapi.NodeMap__cpp__concatenated_write(self, concatenator, feature_streaming)

    def concatenated_write(self, concatenator_dict, feature_streaming=True):
        concatenator = _NodeWriteConcatenator(self._create_new_write_concatenator())
        for key in concatenator_dict.keys():
            concatenator.add(key, concatenator_dict[key])
        was_successful, messages = self._cpp__concatenated_write(concatenator, feature_streaming)
        return ExecutionResult(was_successful=was_successful, messages=messages)

    def _set_nodes(self, value):
        execution_result = self.concatenated_write(value, True)
        if not execution_result.was_successful:
            pass  # TODO: raise an exception.


    def has_node(self, names, condition='matches'):
        if type(names) is list or type(names) is tuple:
    # Multiple queries:
            if condition == 'matches':
                for name in names:
                    if not hasattr(self, name):
                        return False
                return True
            elif condition == 'contains':
                for name in names:
                    if hasattr(self, name):
                        return True
                return False
            else:
                raise ValueError('Specified condition {0} is not supported.'.format(condition))
        elif type(names) is str:
    # Single query:
            return hasattr(self, names)
        else:
            raise TypeError('Queried information is not in any of list, str, or tuple.')

    def __getattr__(self, attribute):
        if attribute in self.__dict__ or attribute in ("thisown", "this") or \
                attribute == '_concrete_port':
            return object.__getattr__(self, attribute)
        else:
            try:
                return self.get_node(attribute)
            except LogicalErrorException as e:
    # Raise AttributeError to naturally work with
    # the hasattr function:
                raise AttributeError from e

    def __setattr__(self, attribute, val):
        if any([attribute in self.__dict__,
                attribute in ("thisown", "this"),
                attribute == '_concrete_port',
                attribute == 'nodes']):
            object.__setattr__(self, attribute, val)
        else:
            warn('Rewrite the code with {0}.value = {1} instead.'.format(attribute, val), DeprecationWarning, stacklevel=2)
            self.get_node(attribute).set_value(val)

    def __dir__(self):
        l = []
        l += [x for x in dir(type(self))]
        l += [x for x in self.__dict__.keys()]
        try:
            l += [x.node.name for x in filter(lambda n: n.node.is_feature(), self.nodes)]
        except:
            pass
        return sorted(set(l))

    def connect(self, *args):
    # Hold the ConcretePort object on _concrete_port attribute as
    # long as the node map exists.
        self._concrete_port = args[0]
        return self._connect(*args)

    def disconnect(self):
        self._concrete_port = None

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.__del__()

    def __del__(self):
        self.disconnect()



    nodes = property(_get_nodes, _set_nodes)


# Register NodeMap in _genapi:
_genapi.NodeMap_swigregister(NodeMap)

def NodeMap_clear_xml_cache():
    return _genapi.NodeMap_clear_xml_cache()

class IFloat(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primary_set_value(self, Value, Verify=True):
        return _genapi.IFloat__primary_set_value(self, Value, Verify)

    def _primary_get_value(self, Verify=False, IgnoreCache=False):
        return _genapi.IFloat__primary_get_value(self, Verify, IgnoreCache)

    def __call__(self):
        return _genapi.IFloat___call__(self)

    def _get_min(self):
        return _genapi.IFloat__get_min(self)

    def _get_max(self):
        return _genapi.IFloat__get_max(self)

    def has_inc(self):
        return _genapi.IFloat_has_inc(self)

    def _get_inc_mode(self):
        return _genapi.IFloat__get_inc_mode(self)

    def _get_inc(self):
        return _genapi.IFloat__get_inc(self)

    def _get_list_of_valid_values(self, bounded=True):
        return _genapi.IFloat__get_list_of_valid_values(self, bounded)

    def _get_representation(self):
        return _genapi.IFloat__get_representation(self)

    def _get_unit(self):
        return _genapi.IFloat__get_unit(self)

    def _get_display_notation(self):
        return _genapi.IFloat__get_display_notation(self)

    def _get_display_precision(self):
        return _genapi.IFloat__get_display_precision(self)

    def impose_min(self, Value):
        return _genapi.IFloat_impose_min(self, Value)

    def impose_max(self, Value):
        return _genapi.IFloat_impose_max(self, Value)

    def _get_int_alias(self):
        return _genapi.IFloat__get_int_alias(self)

    def _get_enum_alias(self):
        return _genapi.IFloat__get_enum_alias(self)

    min = property(_get_min)


    max = property(_get_max)


    inc_mode = property(_get_inc_mode)


    inc = property(_get_inc)


    list_of_valid_values = property(_get_list_of_valid_values)


    representation = property(_get_representation)


    unit = property(_get_unit)


    display_notation = property(_get_display_notation)


    display_precision = property(_get_display_precision)


    int_alias = property(_get_int_alias)


    enum_alias = property(_get_enum_alias)


    def _get_value(self):
        return self._primary_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primary_get_value(verify, ignore_cache)


    def _set_value(self, value):
        if isinstance(value, str):
            self.from_string(value)
        else:
            self._primary_set_value(value)

    def set_value(self, value, verify = True):
        self._primary_set_value(value, verify)


    value = property(_get_value, _set_value)


# Register IFloat in _genapi:
_genapi.IFloat_swigregister(IFloat)

class IInteger(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primary_set_value(self, Value, Verify=True):
        return _genapi.IInteger__primary_set_value(self, Value, Verify)

    def _primary_get_value(self, Verify=False, IgnoreCache=False):
        return _genapi.IInteger__primary_get_value(self, Verify, IgnoreCache)

    def __call__(self):
        return _genapi.IInteger___call__(self)

    def _get_min(self):
        return _genapi.IInteger__get_min(self)

    def _get_max(self):
        return _genapi.IInteger__get_max(self)

    def _get_inc_mode(self):
        return _genapi.IInteger__get_inc_mode(self)

    def _get_inc(self):
        return _genapi.IInteger__get_inc(self)

    def _get_list_of_valid_values(self, bounded=True):
        return _genapi.IInteger__get_list_of_valid_values(self, bounded)

    def _get_representation(self):
        return _genapi.IInteger__get_representation(self)

    def _get_unit(self):
        return _genapi.IInteger__get_unit(self)

    def impose_min(self, Value):
        return _genapi.IInteger_impose_min(self, Value)

    def impose_max(self, Value):
        return _genapi.IInteger_impose_max(self, Value)

    def _get_float_alias(self):
        return _genapi.IInteger__get_float_alias(self)

    def set(self, buffer, Verify=True):
        return _genapi.IInteger_set(self, buffer, Verify)

    def get(self, buffer, Verify=False, IgnoreCache=False):
        return _genapi.IInteger_get(self, buffer, Verify, IgnoreCache)

    def _get_length(self):
        return _genapi.IInteger__get_length(self)

    def _get_address(self):
        return _genapi.IInteger__get_address(self)

    min = property(_get_min)


    max = property(_get_max)


    inc_mode = property(_get_inc_mode)


    inc = property(_get_inc)


    list_of_valid_values = property(_get_list_of_valid_values)


    representation = property(_get_representation)


    unit = property(_get_unit)


    address = property(_get_address)


    length = property(_get_length)


    float_alias = property(_get_float_alias)


    def _get_value(self):
        return self._primary_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primary_get_value(verify, ignore_cache)


    def _set_value(self, value):
        if isinstance(value, str):
            self.from_string(value)
        else:
            self._primary_set_value(value)

    def set_value(self, value, verify = True):
        self._primary_set_value(value, verify)


    value = property(_get_value, _set_value)


# Register IInteger in _genapi:
_genapi.IInteger_swigregister(IInteger)

class IRegister(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set(self, buffer, Verify=True):
        return _genapi.IRegister_set(self, buffer, Verify)

    def get(self, buffer, Verify=False, IgnoreCache=False):
        return _genapi.IRegister_get(self, buffer, Verify, IgnoreCache)

    def _get_length(self):
        return _genapi.IRegister__get_length(self)

    def _get_address(self):
        return _genapi.IRegister__get_address(self)

    length = property(_get_length)


    address = property(_get_address)


    def GetAll(self):
        return self.Get(self.GetLength())


# Register IRegister in _genapi:
_genapi.IRegister_swigregister(IRegister)

class IEnumEntry(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primary_get_value(self):
        return _genapi.IEnumEntry__primary_get_value(self)

    def _get_symbolic(self):
        return _genapi.IEnumEntry__get_symbolic(self)

    def _get_numeric_value(self):
        return _genapi.IEnumEntry__get_numeric_value(self)

    def is_self_clearing(self):
        return _genapi.IEnumEntry_is_self_clearing(self)

    symbolic = property(_get_symbolic)


    numeric_value = property(_get_numeric_value)


    def __call__( self ):
        return self.get_value()


    def _get_value(self):
        return self._primary_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primary_get_value(verify, ignore_cache)


    def _set_value(self, value):
        if isinstance(value, str):
            self.from_string(value)
        else:
            self._primary_set_value(value)

    def set_value(self, value, verify = True):
        self._primary_set_value(value, verify)


    value = property(_get_value, _set_value)


# Register IEnumEntry in _genapi:
_genapi.IEnumEntry_swigregister(IEnumEntry)

class IEnumeration(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_symbolics(self):
        return _genapi.IEnumeration__get_symbolics(self)

    def _get_entries(self):
        return _genapi.IEnumeration__get_entries(self)

    def set_int_value(self, Value, Verify=True):
        return _genapi.IEnumeration_set_int_value(self, Value, Verify)

    def get_int_value(self, Verify=False, IgnoreCache=False):
        return _genapi.IEnumeration_get_int_value(self, Verify, IgnoreCache)

    def get_entry_by_name(self, Symbolic):
        return _genapi.IEnumeration_get_entry_by_name(self, Symbolic)

    def get_entry(self, IntValue):
        return _genapi.IEnumeration_get_entry(self, IntValue)

    def get_current_entry(self, Verify=False, IgnoreCache=False):
        return _genapi.IEnumeration_get_current_entry(self, Verify, IgnoreCache)

    def __call__(self):
        return _genapi.IEnumeration___call__(self)

    def _primary_get_value(self, verify=False, ignore_cache=False):
        return _genapi.IEnumeration__primary_get_value(self, verify, ignore_cache)

    def _primary_set_value(self, entry, verify=False):
        return _genapi.IEnumeration__primary_set_value(self, entry, verify)

    symbolics = property(_get_symbolics)


    entries = property(_get_entries)


    def _get_value(self):
        return self._primary_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primary_get_value(verify, ignore_cache)


    def _set_value(self, value):
        if isinstance(value, str):
            self.from_string(value)
        else:
            self._primary_set_value(value)

    def set_value(self, value, verify = True):
        self._primary_set_value(value, verify)


    value = property(_get_value, _set_value)


# Register IEnumeration in _genapi:
_genapi.IEnumeration_swigregister(IEnumeration)

class IBoolean(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primary_set_value(self, Value, Verify=True):
        return _genapi.IBoolean__primary_set_value(self, Value, Verify)

    def _primary_get_value(self, Verify=False, IgnoreCache=False):
        return _genapi.IBoolean__primary_get_value(self, Verify, IgnoreCache)

    def __call__(self):
        return _genapi.IBoolean___call__(self)

    def _get_value(self):
        return self._primary_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primary_get_value(verify, ignore_cache)


    def _set_value(self, value):
        if isinstance(value, str):
            self.from_string(value)
        else:
            self._primary_set_value(value)

    def set_value(self, value, verify = True):
        self._primary_set_value(value, verify)


    value = property(_get_value, _set_value)


# Register IBoolean in _genapi:
_genapi.IBoolean_swigregister(IBoolean)

class ICommand(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def execute(self, Verify=True):
        return _genapi.ICommand_execute(self, Verify)

    def __call__(self):
        return _genapi.ICommand___call__(self)

    def is_done(self, Verify=False):
        return _genapi.ICommand_is_done(self, Verify)

# Register ICommand in _genapi:
_genapi.ICommand_swigregister(ICommand)

class IString(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primary_set_value(self, Value, Verify=True):
        return _genapi.IString__primary_set_value(self, Value, Verify)

    def _primary_get_value(self, Verify=False, IgnoreCache=False):
        return _genapi.IString__primary_get_value(self, Verify, IgnoreCache)

    def __call__(self):
        return _genapi.IString___call__(self)

    def _get_max_length(self):
        return _genapi.IString__get_max_length(self)

    def _get_length(self):
        return _genapi.IString__get_length(self)

    max_length = property(_get_max_length)


    length = property(_get_length)


    def _get_value(self):
        return self._primary_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primary_get_value(verify, ignore_cache)


    def _set_value(self, value):
        self._primary_set_value(value)

    def set_value(self, value, verify = True):
        self._primary_set_value(value, verify)


    value = property(_get_value, _set_value)


# Register IString in _genapi:
_genapi.IString_swigregister(IString)

class ICategory(IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_features(self):
        return _genapi.ICategory__get_features(self)

    features = property(_get_features)


# Register ICategory in _genapi:
_genapi.ICategory_swigregister(ICategory)

class IReference(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_reference(self, pBase):
        return _genapi.IReference_set_reference(self, pBase)

# Register IReference in _genapi:
_genapi.IReference_swigregister(IReference)

class IEnumReference(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_enum_reference(self, Index, Name):
        return _genapi.IEnumReference_set_enum_reference(self, Index, Name)

    def set_num_enums(self, NumEnums):
        return _genapi.IEnumReference_set_num_enums(self, NumEnums)

# Register IEnumReference in _genapi:
_genapi.IEnumReference_swigregister(IEnumReference)

class ISelector(IBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def is_selector(self):
        return _genapi.ISelector_is_selector(self)

    def _get_selected_features(self):
        return _genapi.ISelector__get_selected_features(self)

    def _get_selecting_features(self):
        return _genapi.ISelector__get_selecting_features(self)

    selected_features = property(_get_selected_features)


    selecting_features = property(_get_selecting_features)


# Register ISelector in _genapi:
_genapi.ISelector_swigregister(ISelector)

class ISelectorDigit(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_first(self):
        return _genapi.ISelectorDigit_set_first(self)

    def set_next(self, Tick=True):
        return _genapi.ISelectorDigit_set_next(self, Tick)

    def restore(self):
        return _genapi.ISelectorDigit_restore(self)

    def to_string(self):
        return _genapi.ISelectorDigit_to_string(self)

    def get_selector_list(self, Incremental=False):
        return _genapi.ISelectorDigit_get_selector_list(self, Incremental)

# Register ISelectorDigit in _genapi:
_genapi.ISelectorDigit_swigregister(ISelectorDigit)

class SelectorSet(ISelectorDigit):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pBase):
        _genapi.SelectorSet_swiginit(self, _genapi.new_SelectorSet(pBase))
    __swig_destroy__ = _genapi.delete_SelectorSet

    def is_empty(self):
        return _genapi.SelectorSet_is_empty(self)

    def set_first(self):
        return _genapi.SelectorSet_set_first(self)

    def set_next(self, Tick=True):
        return _genapi.SelectorSet_set_next(self, Tick)

    def restore(self):
        return _genapi.SelectorSet_restore(self)

    def to_string(self):
        return _genapi.SelectorSet_to_string(self)

    def get_selector_list(self, Incremental=False):
        return _genapi.SelectorSet_get_selector_list(self, Incremental)

# Register SelectorSet in _genapi:
_genapi.SelectorSet_swigregister(SelectorSet)

class _ChunkPort(IPortConstruct):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pPort=None):
        _genapi._ChunkPort_swiginit(self, _genapi.new__ChunkPort(pPort))
    __swig_destroy__ = _genapi.delete__ChunkPort

    def _get_access_mode(self):
        return _genapi._ChunkPort__get_access_mode(self)

    def _get_principal_interface_type(self):
        return _genapi._ChunkPort__get_principal_interface_type(self)

    def read(self, buffer, address, Length):
        return _genapi._ChunkPort_read(self, buffer, address, Length)

    def write(self, buffer, address, Length):
        return _genapi._ChunkPort_write(self, buffer, address, Length)

    def set_port_impl(self, pPort):
        return _genapi._ChunkPort_set_port_impl(self, pPort)

    def _get_swap_endianess(self):
        return _genapi._ChunkPort__get_swap_endianess(self)

    def invalidate_node(self):
        return _genapi._ChunkPort_invalidate_node(self)

    def attach_port(self, pPort):
        return _genapi._ChunkPort_attach_port(self, pPort)

    def detach_port(self):
        return _genapi._ChunkPort_detach_port(self)

    def attach_chunk(self, pBaseAddress, ChunkOffset, Length, Cache):
        return _genapi._ChunkPort_attach_chunk(self, pBaseAddress, ChunkOffset, Length, Cache)

    def detach_chunk(self):
        return _genapi._ChunkPort_detach_chunk(self)

    def _get_chunk_id_length(self):
        return _genapi._ChunkPort__get_chunk_id_length(self)

    def check_chunk_id(self, *args):
        return _genapi._ChunkPort_check_chunk_id(self, *args)

    def update_buffer(self, pBaseAddress):
        return _genapi._ChunkPort_update_buffer(self, pBaseAddress)

    def clear_cache(self):
        return _genapi._ChunkPort_clear_cache(self)

    principal_interface_type = property(_get_principal_interface_type)


    access_mode = property(_get_access_mode)


    swap_endianess = property(_get_swap_endianess)


    chunk_id_length = property(_get_chunk_id_length)


# Register _ChunkPort in _genapi:
_genapi._ChunkPort_swigregister(_ChunkPort)


class ChunkAdapter:
    def __init__(self, node_map=None, max_chunk_cache_size=-1):
#
        self._node_map = node_map
        self._max_chunk_cache_size = max_chunk_cache_size
        self._effective_size = 0
        self._adapter = None
        self._buffer = None
#
        self._finalizer = weakref.finalize(self, self._destruct)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._destruct()

    def attach_node_map(self, node_map):
        self._node_map = node_map
        self._adapter.attach_node_map(self._node_map.pointer)

    def _destruct(self):
        self._adapter.detach_buffer()
        self._adapter.detach_node_map()

    def detach_node_map(self):
        self._adapter.detach_node_map()
        self._node_map = None

    def check_buffer_layout(self, buffer, effective_size):
        return self._adapter.check_buffer_layout(buffer, effective_size)

    def attach_buffer(self, buffer, effective_size, statistics=None):
        self._buffer = buffer
        self._effective_size = effective_size
        self._adapter.attach_buffer(
            self._buffer, self._effective_size, statistics)

    def detach_buffer(self):
        self._adapter.detach_buffer()
        self._buffer = None

    def update_buffer(self, buffer):
        self._buffer = buffer
        self._adapter.update_buffer(self._buffer)

    def clear_caches(self):
        self._adapter.clear_caches()


class ChunkAdapterGeneric(ChunkAdapter):
    def __init__(self, node_map=None, max_chunk_cache_size=-1):
        super().__init__(node_map, max_chunk_cache_size)
        self._single_chunk_data_list = None
        if self._node_map:
            self._adapter = _ChunkAdapterGeneric(
                pNodeMap=self._node_map.pointer,
                MaxChunkCacheSize=self._max_chunk_cache_size
            )
        else:
            self._adapter = _ChunkAdapterGeneric()

    def attach_buffer(self, buffer, single_chunk_data_list, statistics=None):
        self._buffer = buffer
        self._single_chunk_data_list = single_chunk_data_list
        self._adapter.attach_buffer(self._buffer,
                                    single_chunk_data_list, statistics)

class ChunkAdapterGEV(ChunkAdapter):
    def __init__(self, node_map=None, max_chunk_cache_size=-1):
        super().__init__(node_map, max_chunk_cache_size)
        if self._node_map:
            self._adapter = _ChunkAdapterGEV(
                pNodeMap=self._node_map.pointer,
                MaxChunkCacheSize=self._max_chunk_cache_size
            )
        else:
            self._adapter = _ChunkAdapterGEV()


class ChunkAdapterU3V(ChunkAdapter):
    def __init__(self, node_map=None, max_chunk_cache_size=-1):
        super().__init__(node_map, max_chunk_cache_size)
        if self._node_map:
            self._adapter = _ChunkAdapterU3V(
                pNodeMap=self._node_map.pointer,
                MaxChunkCacheSize=self._max_chunk_cache_size
            )
        else:
            self._adapter = _ChunkAdapterU3V()


class ChunkAdapterGenDC(ChunkAdapterU3V):
    def __init__(self, node_map=None, max_chunk_cache_size=-1):
        super().__init__(node_map, max_chunk_cache_size)
        if self._node_map:
            self._adapter = _ChunkAdapterGenDC(
                pNodeMap=self._node_map.pointer,
                MaxChunkCacheSize=self._max_chunk_cache_size
            )
        else:
            self._adapter = _ChunkAdapterGenDC()

class AttachStatistics(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num_chunk_ports = property(_genapi.AttachStatistics_num_chunk_ports_get)
    num_chunks = property(_genapi.AttachStatistics_num_chunks_get)
    num_attached_chunks = property(_genapi.AttachStatistics_num_attached_chunks_get)

    def __init__(self):
        _genapi.AttachStatistics_swiginit(self, _genapi.new_AttachStatistics())
    __swig_destroy__ = _genapi.delete_AttachStatistics

# Register AttachStatistics in _genapi:
_genapi.AttachStatistics_swigregister(AttachStatistics)

class _ChunkAdapter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genapi.delete__ChunkAdapter

    def attach_node_map(self, pNodeMap):
        return _genapi._ChunkAdapter_attach_node_map(self, pNodeMap)

    def detach_node_map(self):
        return _genapi._ChunkAdapter_detach_node_map(self)

    def check_buffer_layout(self, pChunkBuffer_, BufferLength):
        return _genapi._ChunkAdapter_check_buffer_layout(self, pChunkBuffer_, BufferLength)

    def attach_buffer(self, pChunkBuffer_, BufferLength, pAttachStatistics=None):
        return _genapi._ChunkAdapter_attach_buffer(self, pChunkBuffer_, BufferLength, pAttachStatistics)

    def detach_buffer(self):
        return _genapi._ChunkAdapter_detach_buffer(self)

    def update_buffer(self, pBaseAddress):
        return _genapi._ChunkAdapter_update_buffer(self, pBaseAddress)

    def clear_caches(self):
        return _genapi._ChunkAdapter_clear_caches(self)

# Register _ChunkAdapter in _genapi:
_genapi._ChunkAdapter_swigregister(_ChunkAdapter)

class _ChunkAdapterU3V(_ChunkAdapter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None, MaxChunkCacheSize=-1):
        _genapi._ChunkAdapterU3V_swiginit(self, _genapi.new__ChunkAdapterU3V(pNodeMap, MaxChunkCacheSize))
    __swig_destroy__ = _genapi.delete__ChunkAdapterU3V

    def check_buffer_layout(self, pChunkBuffer_, BufferLength):
        return _genapi._ChunkAdapterU3V_check_buffer_layout(self, pChunkBuffer_, BufferLength)

    def attach_buffer(self, pChunkBuffer_, BufferLength, pAttachStatistics=None):
        return _genapi._ChunkAdapterU3V_attach_buffer(self, pChunkBuffer_, BufferLength, pAttachStatistics)

# Register _ChunkAdapterU3V in _genapi:
_genapi._ChunkAdapterU3V_swigregister(_ChunkAdapterU3V)

class _ChunkAdapterGenDC(_ChunkAdapterU3V):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None, MaxChunkCacheSize=-1):
        _genapi._ChunkAdapterGenDC_swiginit(self, _genapi.new__ChunkAdapterGenDC(pNodeMap, MaxChunkCacheSize))
    __swig_destroy__ = _genapi.delete__ChunkAdapterGenDC

    def check_buffer_layout(self, pChunkBuffer_, BufferLength):
        return _genapi._ChunkAdapterGenDC_check_buffer_layout(self, pChunkBuffer_, BufferLength)

    def attach_buffer(self, pChunkBuffer_, BufferLength, pAttachStatistics=None):
        return _genapi._ChunkAdapterGenDC_attach_buffer(self, pChunkBuffer_, BufferLength, pAttachStatistics)

# Register _ChunkAdapterGenDC in _genapi:
_genapi._ChunkAdapterGenDC_swigregister(_ChunkAdapterGenDC)

class _ChunkAdapterGEV(_ChunkAdapter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None, MaxChunkCacheSize=-1):
        _genapi._ChunkAdapterGEV_swiginit(self, _genapi.new__ChunkAdapterGEV(pNodeMap, MaxChunkCacheSize))
    __swig_destroy__ = _genapi.delete__ChunkAdapterGEV

    def check_buffer_layout(self, pChunkBuffer_, BufferLength):
        return _genapi._ChunkAdapterGEV_check_buffer_layout(self, pChunkBuffer_, BufferLength)

    def attach_buffer(self, pChunkBuffer_, BufferLength, pAttachStatistics=None):
        return _genapi._ChunkAdapterGEV_attach_buffer(self, pChunkBuffer_, BufferLength, pAttachStatistics)

# Register _ChunkAdapterGEV in _genapi:
_genapi._ChunkAdapterGEV_swigregister(_ChunkAdapterGEV)

class SingleChunkData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    chunk_id = property(_genapi.SingleChunkData_chunk_id_get, _genapi.SingleChunkData_chunk_id_set)
    chunk_offset = property(_genapi.SingleChunkData_chunk_offset_get, _genapi.SingleChunkData_chunk_offset_set)
    chunk_length = property(_genapi.SingleChunkData_chunk_length_get, _genapi.SingleChunkData_chunk_length_set)

    def __init__(self):
        _genapi.SingleChunkData_swiginit(self, _genapi.new_SingleChunkData())
    __swig_destroy__ = _genapi.delete_SingleChunkData

# Register SingleChunkData in _genapi:
_genapi.SingleChunkData_swigregister(SingleChunkData)

class _SingleChunkData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChunkID = property(_genapi._SingleChunkData_ChunkID_get, _genapi._SingleChunkData_ChunkID_set)
    ChunkOffset = property(_genapi._SingleChunkData_ChunkOffset_get, _genapi._SingleChunkData_ChunkOffset_set)
    ChunkLength = property(_genapi._SingleChunkData_ChunkLength_get, _genapi._SingleChunkData_ChunkLength_set)

    def __init__(self):
        _genapi._SingleChunkData_swiginit(self, _genapi.new__SingleChunkData())
    __swig_destroy__ = _genapi.delete__SingleChunkData

# Register _SingleChunkData in _genapi:
_genapi._SingleChunkData_swigregister(_SingleChunkData)

class _ChunkAdapterGeneric(_ChunkAdapter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None, MaxChunkCacheSize=-1):
        _genapi._ChunkAdapterGeneric_swiginit(self, _genapi.new__ChunkAdapterGeneric(pNodeMap, MaxChunkCacheSize))
    __swig_destroy__ = _genapi.delete__ChunkAdapterGeneric

    def check_buffer_layout(self, buffer):
        return _genapi._ChunkAdapterGeneric_check_buffer_layout(self, buffer)

    def attach_buffer(self, *args):
        return _genapi._ChunkAdapterGeneric_attach_buffer(self, *args)

# Register _ChunkAdapterGeneric in _genapi:
_genapi._ChunkAdapterGeneric_swigregister(_ChunkAdapterGeneric)

class EventPort(IPortConstruct):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNode=None):
        _genapi.EventPort_swiginit(self, _genapi.new_EventPort(pNode))
    __swig_destroy__ = _genapi.delete_EventPort

    def _get_access_mode(self):
        return _genapi.EventPort__get_access_mode(self)

    def _get_principal_interface_type(self):
        return _genapi.EventPort__get_principal_interface_type(self)

    def read(self, buffer, address, Length):
        return _genapi.EventPort_read(self, buffer, address, Length)

    def write(self, buffer, address, Length):
        return _genapi.EventPort_write(self, buffer, address, Length)

    def set_port_impl(self, pPort):
        return _genapi.EventPort_set_port_impl(self, pPort)

    def _get_swap_endianess(self):
        return _genapi.EventPort__get_swap_endianess(self)

    def invalidate_node(self):
        return _genapi.EventPort_invalidate_node(self)

    def attach_node(self, pNode):
        return _genapi.EventPort_attach_node(self, pNode)

    def detach_node(self):
        return _genapi.EventPort_detach_node(self)

    def _get_event_id_length(self):
        return _genapi.EventPort__get_event_id_length(self)

    def check_event_id(self, *args):
        return _genapi.EventPort_check_event_id(self, *args)

    def attach_event(self, pBaseAddress, Length):
        return _genapi.EventPort_attach_event(self, pBaseAddress, Length)

    def detach_event(self):
        return _genapi.EventPort_detach_event(self)

    principal_interface_type = property(_get_principal_interface_type)


    access_mode = property(_get_access_mode)


    swap_endianess = property(_get_swap_endianess)


    event_id_length = property(_get_event_id_length)


# Register EventPort in _genapi:
_genapi.EventPort_swigregister(EventPort)

class EventAdapter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genapi.delete_EventAdapter

    def attach_node_map(self, pNodeMap):
        return _genapi.EventAdapter_attach_node_map(self, pNodeMap)

    def detach_node_map(self):
        return _genapi.EventAdapter_detach_node_map(self)

    def deliver_message(self, msg):
        return _genapi.EventAdapter_deliver_message(self, msg)

# Register EventAdapter in _genapi:
_genapi.EventAdapter_swigregister(EventAdapter)

class EventAdapterGEV(EventAdapter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None):
        _genapi.EventAdapterGEV_swiginit(self, _genapi.new_EventAdapterGEV(pNodeMap))
    __swig_destroy__ = _genapi.delete_EventAdapterGEV

    def deliver_message(self, msg):
        return _genapi.EventAdapterGEV_deliver_message(self, msg)

# Register EventAdapterGEV in _genapi:
_genapi.EventAdapterGEV_swigregister(EventAdapterGEV)

class EventAdapterU3V(EventAdapter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None):
        _genapi.EventAdapterU3V_swiginit(self, _genapi.new_EventAdapterU3V(pNodeMap))
    __swig_destroy__ = _genapi.delete_EventAdapterU3V

    def deliver_message(self, msg):
        return _genapi.EventAdapterU3V_deliver_message(self, msg)

# Register EventAdapterU3V in _genapi:
_genapi.EventAdapterU3V_swigregister(EventAdapterU3V)

class EventAdapterCL(EventAdapter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None):
        _genapi.EventAdapterCL_swiginit(self, _genapi.new_EventAdapterCL(pNodeMap))
    __swig_destroy__ = _genapi.delete_EventAdapterCL

    def deliver_message(self, msg):
        return _genapi.EventAdapterCL_deliver_message(self, msg)

# Register EventAdapterCL in _genapi:
_genapi.EventAdapterCL_swigregister(EventAdapterCL)

class EventAdapterGeneric(EventAdapter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None):
        _genapi.EventAdapterGeneric_swiginit(self, _genapi.new_EventAdapterGeneric(pNodeMap))
    __swig_destroy__ = _genapi.delete_EventAdapterGeneric

    def deliver_message(self, *args):
        return _genapi.EventAdapterGeneric_deliver_message(self, *args)

# Register EventAdapterGeneric in _genapi:
_genapi.EventAdapterGeneric_swigregister(EventAdapterGeneric)

class FileProtocolAdapter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _genapi.FileProtocolAdapter_swiginit(self, _genapi.new_FileProtocolAdapter())

    def attach(self, pInterface):
        return _genapi.FileProtocolAdapter_attach(self, pInterface)

    def open_file(self, pFileName, mode):
        return _genapi.FileProtocolAdapter_open_file(self, pFileName, mode)

    def close_file(self, pFileName):
        return _genapi.FileProtocolAdapter_close_file(self, pFileName)

    def write(self, buffer, offs, pFileName):
        return _genapi.FileProtocolAdapter_write(self, buffer, offs, pFileName)

    def read(self, buffer, offs, pFileName):
        return _genapi.FileProtocolAdapter_read(self, buffer, offs, pFileName)

    def get_buf_size(self, pFileName, mode):
        return _genapi.FileProtocolAdapter_get_buf_size(self, pFileName, mode)

    def delete_file(self, pFileName):
        return _genapi.FileProtocolAdapter_delete_file(self, pFileName)

    class FileAccess(object):
        def __init__(self, read_bufsize = 4096):
            if read_bufsize == 0:
                raise IOError("invalid read_bufsize")

            self.isopen   = False
            self.filename = ""
            self.mode     = ""
            self.fpa      = FileProtocolAdapter()
            self.fpa_bufsize  = 0
            self.fpos     = 0
            self.read_bufsize = read_bufsize

        def open(self, nodemap, filename, openmode):
            self.fpa.attach(nodemap)
            self.filename = filename
            self.fpa.openFile(filename,openmode)
            self.fpa_bufsize = self.fpa.getBufSize(filename, openmode)
            self.fpos = 0
            self.isopen = True

        def close(self):
            self.isopen = False
            self.fpa.closeFile(self.filename)

        def _read(self, size):
            assert(self.isopen)
            buf = ""
            for ofs in xrange(0, size, self.fpa_bufsize):
                read_len, data  = self.fpa.read(self.fpa_bufsize, self.fpos + ofs, self.filename)
                if read_len <= 0:
                    break
                else:
                    buf += data[:min(size-ofs,read_len)]

            self.fpos += len(buf)
            return buf

        def read(self, size = -1):
            assert(self.isopen)
            if size < 0:
                buf = ""
                while True:
                    data  = self._read(self.read_bufsize)
                    buf += data
                    if len(data) < self.read_bufsize:
                        return buf

            else:
                data  = self._read(size)
                return data


        def write(self,data):
            assert(self.isopen)
            ret = self.fpa.write(data, self.fpos, self.filename)
            self.fpos += len(data)
            return ret

    __swig_destroy__ = _genapi.delete_FileProtocolAdapter

# Register FileProtocolAdapter in _genapi:
_genapi.FileProtocolAdapter_swigregister(FileProtocolAdapter)


class ErrorList:
    def __init__(self, messages=None):
        super().__init__()
        self._messages = messages if messages else list()

    @property
    def messages(self):
        return self._messages


class ExecutionResult(ErrorList):
    def __init__(self, was_successful=None, messages=None):
        super().__init__(messages=messages)
        self._was_successful = was_successful

    @property
    def was_successful(self):
        return self._was_successful


class ValidationResult(ErrorList):
    def __init__(self, is_valid=None, messages=None):
        super().__init__(messages=messages)
        self._is_valid = is_valid

    @property
    def is_valid(self):
        return self._is_valid




